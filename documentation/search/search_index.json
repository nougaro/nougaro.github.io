{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Nougaro documentation Warning This documentation is a work-in-progress and is not actually the most up-to-date source of information. For the actual documentation (that will soon be moved here), see the wiki Overview Nougaro is an interpreted dynamic-typed programming language. Choose your version 0.22 License This document is under the GNU FDL licence. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\".","title":"Welcome to the Nougaro documentation"},{"location":"#welcome-to-the-nougaro-documentation","text":"Warning This documentation is a work-in-progress and is not actually the most up-to-date source of information. For the actual documentation (that will soon be moved here), see the wiki","title":"Welcome to the Nougaro documentation"},{"location":"#overview","text":"Nougaro is an interpreted dynamic-typed programming language.","title":"Overview"},{"location":"#choose-your-version","text":"0.22","title":"Choose your version"},{"location":"#license","text":"This document is under the GNU FDL licence. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\".","title":"License"},{"location":"0.22/","text":"Nougaro 0.22.0-beta documentation This is the official documentation for Nougaro version 0.22.0-beta. Hello, world! Language reference: syntax, statements, \u2026 Basic syntax Number literals String literals Identifiers and keywords Operators Values Variables Tests (if statement) Loops Functions Attributes Classes Read and write in files Import and export Metas Standard library reference: builtins, modules, \u2026 Expanding Nougaro (for Python developers) Write libraries for Nougaro Internals","title":"Nougaro 0.22.0-beta documentation"},{"location":"0.22/#nougaro-0220-beta-documentation","text":"This is the official documentation for Nougaro version 0.22.0-beta. Hello, world! Language reference: syntax, statements, \u2026 Basic syntax Number literals String literals Identifiers and keywords Operators Values Variables Tests (if statement) Loops Functions Attributes Classes Read and write in files Import and export Metas Standard library reference: builtins, modules, \u2026 Expanding Nougaro (for Python developers) Write libraries for Nougaro Internals","title":"Nougaro 0.22.0-beta documentation"},{"location":"0.22/hello_world/","text":"Hello, world! This is the \u201cHello, world!\u201d program in Nougaro. print(\"Hello, world!\") Alternatively: import hello If you want to use functionnal programming: def main() print(\"Hello, world!\") end main() If you want to use object-oriented programming: class Main def print_hello_world() print(\"Hello, world!\") end end Main().print_hello_world()","title":"Hello, world!"},{"location":"0.22/hello_world/#hello-world","text":"This is the \u201cHello, world!\u201d program in Nougaro. print(\"Hello, world!\") Alternatively: import hello If you want to use functionnal programming: def main() print(\"Hello, world!\") end main() If you want to use object-oriented programming: class Main def print_hello_world() print(\"Hello, world!\") end end Main().print_hello_world()","title":"Hello, world!"},{"location":"0.22/internals/","text":"Internals Features that had to be documented but that are mainly used for debugging purposes. Context variables __actual_context__ is the name of the function where the code is executed. May be <program> . __exec_from__ is the name of the parent of the function where the code is executed. If __actual_context__ is <program> , __exec_from__ is (shell) . If the code is inside a function foo that is directly in <program> , __exec_from__ is foo from <program> . If the code is inside a function bar executed from our foo (that is in <program> ), __exec_from__ is bar from foo . Base value __base_value__ is the base value (python class Value ). It is the parent class of all the other values. It is the only value to crash on == and != operators .","title":"Internals"},{"location":"0.22/internals/#internals","text":"Features that had to be documented but that are mainly used for debugging purposes.","title":"Internals"},{"location":"0.22/internals/#context-variables","text":"__actual_context__ is the name of the function where the code is executed. May be <program> . __exec_from__ is the name of the parent of the function where the code is executed. If __actual_context__ is <program> , __exec_from__ is (shell) . If the code is inside a function foo that is directly in <program> , __exec_from__ is foo from <program> . If the code is inside a function bar executed from our foo (that is in <program> ), __exec_from__ is bar from foo .","title":"Context variables"},{"location":"0.22/internals/#base-value","text":"__base_value__ is the base value (python class Value ). It is the parent class of all the other values. It is the only value to crash on == and != operators .","title":"Base value"},{"location":"0.22/Expanding/Write-libs/","text":"You are a Nougaro developer, and you want to write an amazing library to implement python amazing things in Nougaro? You're at the right place!! You have to options: either writting it in Nougaro (with limited resources), either writting it in Python (with unlimited resources). Write libs in Nougaro Requirements You need to know how to code in Nougaro. Start coding The file should be named nameofthelib.noug and be located in the lib_ folder in the Nougaro repository. Simply write all your code. If you want something to be accessible when imported, use one of those syntaxes: : * export identifier (as identifier) * export (any expression) as identifier You can find examples of built-in modules written in Nougaro in the lib_ folder. Write libs in Python Warning Everything changed in 0.16.0-beta and in 0.19.0-beta Requirements You need to know how to code in Python. Don't worry, that's easy ;) Start coding The file should be named nameofthelib_.py (the \u201c_\u201d is VERY important!!) The file will be placed in the lib_ folder in the Nougaro repository. Paste this generic code in your file: # -*- coding:utf-8 -*- \"\"\" YourModuleName module YourModuleName is a module that do [...] and [...] and also [...]. \"\"\" # IMPORTS # nougaro modules imports from lib_.lib_to_make_libs import * # useful stuff to make libs. # built-in python imports # here put the useful python imports your module will need ;) __LIB_VERSION__ = 4 Note Lib versions depending on Nougaro versions: prior to 0.20.0: 1 0.20.0: 2 0.21.0: 3 0.22.0: 4 Lib with constants If your lib contains constants, you can add them to the code, outside any class. Use py2noug function imported from lib_to_make_libs to convert Python values to Nougaro values. Python types that can be converted into Nougaro values are: str , int , float , bool (which is converted to 0 or 1), list , tuple (converted into list), dict (converted into a list of lists, each sub-list is [key, value] ), None . Other types will return generic value Value , which you can't make anything with... Example: AMAZING_CONSTANT = py2noug(3, *default_pos()) # will be Number(3), type 'int' ANOTHER_AMAZING_CONSTANT = py2noug(\"Hello world :)\", *default_pos()) # will be String(\"Hello world :)\"), type 'str' ( py2noug and default_pos are imported from lib_to_make_libs ) Lib with functions If you want functions in your lib, paste this code in your file (replace the generic names/texts with appropriate things): class YourModuleName(ModuleFunction): \"\"\" YourModuleName Module \"\"\" functions: dict[str, builtin_function_dict] = {} def __init__(self, function_name: str): super().__init__(\"your_module_name\", function_name, \"https://link_to_report_bugs.com (not required)\", functions=self.functions) def copy(self): \"\"\"Return a copy of self\"\"\" copy = YourModuleName(self.name) return self.set_context_and_pos_to_a_copy(copy) def is_eq(self, other: Value): return isinstance(other, YourModuleName) and self.name == other.name Changed in 0.20.0-beta Prior to 0.20.0, the method is_eq was named get_comparison_eq and had this syntax: def get_comparison_eq(self, other: Value): if isinstance(other, YourModuleName): return Number(self.name == other.name, self.pos_start, other.pos_end).set_context(self.context), None return Number(False, self.pos_start, other.pos_end).set_context(self.context), None Then, to add a function, add a method in this class following this syntax: def execute_function_name(self, context: Context): \"\"\" Docstring (optional) \"\"\" assert context.symbol_table is not None ... functions[\"function_name\"] = { \"function\": execute_function_name, \"param_names\": [\"parameter_1\", \"parameter_2\"], \"optional_params\": [\"optional_parameter_1\"], \"should_respect_args_number\": True, # The two following values are used internally. # They are not documented, don\u2019t set them to True except if you know what you\u2019re doing. \"run_noug_dir\": False, \"noug_dir\": False } Changed in 0.22.0-beta Prior to 0.22.0-beta, the key \"run_noug_dir\" was called \"run_noug_dir_work_dir\" . keys param_names and optional_params should be of type list[str] . should_respect_args_number is a bool. It is True when the number of given arguments should match with the number of parameters, and False if not. You can then add code in your function. Get arguments To get the arguments given by the user in your functions, use context.symbol_table.getf(\"identifier\") Replace the identifier by the one you given to the parameter. If your parameter is optional and that the user didn\u2019t specified it, the default value is a Python None (not a Nougaro NoneValue ). Danger Please don\u2019t use .get symbol table method, it does NOT work in modules (even if it looks like) and should NOT be used. (The short explanation why is that this method looks for the name also in parent symbol table, so if an optional param is not given but the user defined a variable with that name, it will be taken as the value for that param, which is not what we want. We don\u2019t care about parent symbol table, so we just look in the current symbol table which only contains the parameters. The corresponding issue is #10 .) Values Important You often have to switch between Nougaro and Python values! To convert python to Nougaro values, use py2noug function. To convert Nougaro to python values, use noug2py . Both functions are imported from lib_to_make_libs . You reed a position with py2noug : you can simply put self.pos_start and self.pos_end or the position of any value you want. What to return? Values and errors. If you don't need to return anything, simply use return RTResult().success(NoneValue(*default_pos(), False)) . Return errors Oops! It crashed! How to say it to the user under a good shape? Simply use this syntax: return RTResult().failure(NameOfTheError( self.pos_start, self.pos_end, \"error message.\", context )) If the user gave you a value with an incorrect type, use: return RTResult().failure(RTTypeErrorF( bad_argument.pos_start, bad_argument.pos_end, \"first/second/third\u2026\", \"name of the module.name of the function\", \"type that should be found\", bad_argument, context )) Replace \"first/second/third\u2026\" by the actual index of the argument. If it is the first argument, put \"first\" , et c\u00e6tera. The error will print, for instance, second argument of builtin function 'name of the function' should be 'type that should be found', not 'type of (bad_argument)'. You can replace self by any Nougaro value, such as your arguments. For example, in the lib math : if value.value < 0: # we check if the value is greater than (or equal to) 0 return RTResult().failure(RTArithmeticError( value.pos_start, value.pos_end, \"first argument of the built-in function 'math.sqrt' must be greater than (or equal to) 0.\", exec_context, \"lib_.math_.Math.execute_math_sqrt\" )) All the errors available in a Module: RunTimeError : basic run-time error RTIndexError : IndexError RTArithmeticError : ArithmeticError RTNotDefinedError : NotDefinedError RTTypeErrorF : TypeError (you give a Number but you need a String) RTFileNotFoundError : FileNotFoundError RTAssertionError : AssertionError (not useful in libs...) RTAttributeError : AttributeError RTOverflowError : OverflowError RTRecursionError : RecursionError (new in 0.20.0) PythonError : PythonError: an error due to Python. Don\u2019t put a str error message: pass directly the Python Exception. Return values To return a Nougaro value, use return RTResult().success(value) To return a Python value, use return RTResult().success(py2noug(value, self.pos_start, self.pos_end)) WHAT_TO_IMPORT : DO NOT forget that one!! When you have finished coding your amazing lib, create the WHAT_TO_IMPORT dict. It tells to the Nougaro Interpreter what should be imported and with which name. Follow this syntax: WHAT_TO_IMPORT = { \"name_of_a_constant\": IDENTIFIER, \"name_of_a_function\": YourModuleName('function_name'), } The function name is what you specified as the key of the functions dictionary. Custom errors To use a custom error in your code, simply copy-paste this code: class YourErrorName(RunTimeError): \"\"\"YourErrorName is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.(nameofthelib)_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"YourErrorName\", origin_file=origin_file) Then, call it like any other errors (like this ) Note: origin_file is used for debugging. To trigger it, you can run: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> (anything that throws an error) Example: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> thisisnotdefined [identifier:\"thisisnotdefined\", end of file] list:[(var_access:[identifier:\"thisisnotdefined\"], False)] (from src.runtime.interpreter.Interpreter.visit_VarAccessNode (is NOT lib and close match in symbol table)) Traceback (most recent call last): In file <stdin>, line 1, in <program>: thisisnotdefined ^^^^^^^^^^^^^^^^ NotDefinedError: name 'thisisnotdefined' is not defined. Did you mean 'is_none'? nougaro> this is a syntax error [identifier:\"this\", identifier:\"is\", identifier:\"a\", identifier:\"syntax\", identifier:\"error\", end of file] (from src.parser.parser.Parser.statements) In file <stdin>, line 1: this is a syntax error ^^ InvalidSyntaxError: unexpected token: identifier:\"is\". nougaro> Here, origin_file is src.runtime.interpreter.Interpreter.visit_VarAccessNode and src.parser.parser.Parser.parse . Example: RTStatisticsError in built-in lib statistics class RTStatisticsError(RunTimeError): \"\"\"StatisticsError is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.statistics_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"StatisticsError\", origin_file=origin_file) Examples You can read builtin files stored in lib_ folder to make you a good idea of what a nice-coded lib is ;) Here you go! If you think that your lib is absolutely awesome, you can open a PR to submit your idea. The best ideas will be implemented into vanilla Nougaro! If you think that this document is incomplete, that it didn\u2019t help you, or just to find some help, open an issue .","title":"Write libs"},{"location":"0.22/Expanding/Write-libs/#write-libs-in-nougaro","text":"","title":"Write libs in Nougaro"},{"location":"0.22/Expanding/Write-libs/#requirements","text":"You need to know how to code in Nougaro.","title":"Requirements"},{"location":"0.22/Expanding/Write-libs/#start-coding","text":"The file should be named nameofthelib.noug and be located in the lib_ folder in the Nougaro repository. Simply write all your code. If you want something to be accessible when imported, use one of those syntaxes: : * export identifier (as identifier) * export (any expression) as identifier You can find examples of built-in modules written in Nougaro in the lib_ folder.","title":"Start coding"},{"location":"0.22/Expanding/Write-libs/#write-libs-in-python","text":"Warning Everything changed in 0.16.0-beta and in 0.19.0-beta","title":"Write libs in Python"},{"location":"0.22/Expanding/Write-libs/#requirements_1","text":"You need to know how to code in Python. Don't worry, that's easy ;)","title":"Requirements"},{"location":"0.22/Expanding/Write-libs/#start-coding_1","text":"The file should be named nameofthelib_.py (the \u201c_\u201d is VERY important!!) The file will be placed in the lib_ folder in the Nougaro repository. Paste this generic code in your file: # -*- coding:utf-8 -*- \"\"\" YourModuleName module YourModuleName is a module that do [...] and [...] and also [...]. \"\"\" # IMPORTS # nougaro modules imports from lib_.lib_to_make_libs import * # useful stuff to make libs. # built-in python imports # here put the useful python imports your module will need ;) __LIB_VERSION__ = 4 Note Lib versions depending on Nougaro versions: prior to 0.20.0: 1 0.20.0: 2 0.21.0: 3 0.22.0: 4","title":"Start coding"},{"location":"0.22/Expanding/Write-libs/#lib-with-constants","text":"If your lib contains constants, you can add them to the code, outside any class. Use py2noug function imported from lib_to_make_libs to convert Python values to Nougaro values. Python types that can be converted into Nougaro values are: str , int , float , bool (which is converted to 0 or 1), list , tuple (converted into list), dict (converted into a list of lists, each sub-list is [key, value] ), None . Other types will return generic value Value , which you can't make anything with... Example: AMAZING_CONSTANT = py2noug(3, *default_pos()) # will be Number(3), type 'int' ANOTHER_AMAZING_CONSTANT = py2noug(\"Hello world :)\", *default_pos()) # will be String(\"Hello world :)\"), type 'str' ( py2noug and default_pos are imported from lib_to_make_libs )","title":"Lib with constants"},{"location":"0.22/Expanding/Write-libs/#lib-with-functions","text":"If you want functions in your lib, paste this code in your file (replace the generic names/texts with appropriate things): class YourModuleName(ModuleFunction): \"\"\" YourModuleName Module \"\"\" functions: dict[str, builtin_function_dict] = {} def __init__(self, function_name: str): super().__init__(\"your_module_name\", function_name, \"https://link_to_report_bugs.com (not required)\", functions=self.functions) def copy(self): \"\"\"Return a copy of self\"\"\" copy = YourModuleName(self.name) return self.set_context_and_pos_to_a_copy(copy) def is_eq(self, other: Value): return isinstance(other, YourModuleName) and self.name == other.name Changed in 0.20.0-beta Prior to 0.20.0, the method is_eq was named get_comparison_eq and had this syntax: def get_comparison_eq(self, other: Value): if isinstance(other, YourModuleName): return Number(self.name == other.name, self.pos_start, other.pos_end).set_context(self.context), None return Number(False, self.pos_start, other.pos_end).set_context(self.context), None Then, to add a function, add a method in this class following this syntax: def execute_function_name(self, context: Context): \"\"\" Docstring (optional) \"\"\" assert context.symbol_table is not None ... functions[\"function_name\"] = { \"function\": execute_function_name, \"param_names\": [\"parameter_1\", \"parameter_2\"], \"optional_params\": [\"optional_parameter_1\"], \"should_respect_args_number\": True, # The two following values are used internally. # They are not documented, don\u2019t set them to True except if you know what you\u2019re doing. \"run_noug_dir\": False, \"noug_dir\": False } Changed in 0.22.0-beta Prior to 0.22.0-beta, the key \"run_noug_dir\" was called \"run_noug_dir_work_dir\" . keys param_names and optional_params should be of type list[str] . should_respect_args_number is a bool. It is True when the number of given arguments should match with the number of parameters, and False if not. You can then add code in your function.","title":"Lib with functions"},{"location":"0.22/Expanding/Write-libs/#get-arguments","text":"To get the arguments given by the user in your functions, use context.symbol_table.getf(\"identifier\") Replace the identifier by the one you given to the parameter. If your parameter is optional and that the user didn\u2019t specified it, the default value is a Python None (not a Nougaro NoneValue ). Danger Please don\u2019t use .get symbol table method, it does NOT work in modules (even if it looks like) and should NOT be used. (The short explanation why is that this method looks for the name also in parent symbol table, so if an optional param is not given but the user defined a variable with that name, it will be taken as the value for that param, which is not what we want. We don\u2019t care about parent symbol table, so we just look in the current symbol table which only contains the parameters. The corresponding issue is #10 .)","title":"Get arguments"},{"location":"0.22/Expanding/Write-libs/#values","text":"Important You often have to switch between Nougaro and Python values! To convert python to Nougaro values, use py2noug function. To convert Nougaro to python values, use noug2py . Both functions are imported from lib_to_make_libs . You reed a position with py2noug : you can simply put self.pos_start and self.pos_end or the position of any value you want.","title":"Values"},{"location":"0.22/Expanding/Write-libs/#what-to-return-values-and-errors","text":"If you don't need to return anything, simply use return RTResult().success(NoneValue(*default_pos(), False)) .","title":"What to return? Values and errors."},{"location":"0.22/Expanding/Write-libs/#return-errors","text":"Oops! It crashed! How to say it to the user under a good shape? Simply use this syntax: return RTResult().failure(NameOfTheError( self.pos_start, self.pos_end, \"error message.\", context )) If the user gave you a value with an incorrect type, use: return RTResult().failure(RTTypeErrorF( bad_argument.pos_start, bad_argument.pos_end, \"first/second/third\u2026\", \"name of the module.name of the function\", \"type that should be found\", bad_argument, context )) Replace \"first/second/third\u2026\" by the actual index of the argument. If it is the first argument, put \"first\" , et c\u00e6tera. The error will print, for instance, second argument of builtin function 'name of the function' should be 'type that should be found', not 'type of (bad_argument)'. You can replace self by any Nougaro value, such as your arguments. For example, in the lib math : if value.value < 0: # we check if the value is greater than (or equal to) 0 return RTResult().failure(RTArithmeticError( value.pos_start, value.pos_end, \"first argument of the built-in function 'math.sqrt' must be greater than (or equal to) 0.\", exec_context, \"lib_.math_.Math.execute_math_sqrt\" )) All the errors available in a Module: RunTimeError : basic run-time error RTIndexError : IndexError RTArithmeticError : ArithmeticError RTNotDefinedError : NotDefinedError RTTypeErrorF : TypeError (you give a Number but you need a String) RTFileNotFoundError : FileNotFoundError RTAssertionError : AssertionError (not useful in libs...) RTAttributeError : AttributeError RTOverflowError : OverflowError RTRecursionError : RecursionError (new in 0.20.0) PythonError : PythonError: an error due to Python. Don\u2019t put a str error message: pass directly the Python Exception.","title":"Return errors"},{"location":"0.22/Expanding/Write-libs/#return-values","text":"To return a Nougaro value, use return RTResult().success(value) To return a Python value, use return RTResult().success(py2noug(value, self.pos_start, self.pos_end))","title":"Return values"},{"location":"0.22/Expanding/Write-libs/#what_to_import-do-not-forget-that-one","text":"When you have finished coding your amazing lib, create the WHAT_TO_IMPORT dict. It tells to the Nougaro Interpreter what should be imported and with which name. Follow this syntax: WHAT_TO_IMPORT = { \"name_of_a_constant\": IDENTIFIER, \"name_of_a_function\": YourModuleName('function_name'), } The function name is what you specified as the key of the functions dictionary.","title":"WHAT_TO_IMPORT : DO NOT forget that one!!"},{"location":"0.22/Expanding/Write-libs/#custom-errors","text":"To use a custom error in your code, simply copy-paste this code: class YourErrorName(RunTimeError): \"\"\"YourErrorName is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.(nameofthelib)_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"YourErrorName\", origin_file=origin_file) Then, call it like any other errors (like this ) Note: origin_file is used for debugging. To trigger it, you can run: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> (anything that throws an error) Example: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> thisisnotdefined [identifier:\"thisisnotdefined\", end of file] list:[(var_access:[identifier:\"thisisnotdefined\"], False)] (from src.runtime.interpreter.Interpreter.visit_VarAccessNode (is NOT lib and close match in symbol table)) Traceback (most recent call last): In file <stdin>, line 1, in <program>: thisisnotdefined ^^^^^^^^^^^^^^^^ NotDefinedError: name 'thisisnotdefined' is not defined. Did you mean 'is_none'? nougaro> this is a syntax error [identifier:\"this\", identifier:\"is\", identifier:\"a\", identifier:\"syntax\", identifier:\"error\", end of file] (from src.parser.parser.Parser.statements) In file <stdin>, line 1: this is a syntax error ^^ InvalidSyntaxError: unexpected token: identifier:\"is\". nougaro> Here, origin_file is src.runtime.interpreter.Interpreter.visit_VarAccessNode and src.parser.parser.Parser.parse .","title":"Custom errors"},{"location":"0.22/Expanding/Write-libs/#example-rtstatisticserror-in-built-in-lib-statistics","text":"class RTStatisticsError(RunTimeError): \"\"\"StatisticsError is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.statistics_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"StatisticsError\", origin_file=origin_file)","title":"Example: RTStatisticsError in built-in lib statistics"},{"location":"0.22/Expanding/Write-libs/#examples","text":"You can read builtin files stored in lib_ folder to make you a good idea of what a nice-coded lib is ;)","title":"Examples"},{"location":"0.22/Expanding/Write-libs/#here-you-go","text":"If you think that your lib is absolutely awesome, you can open a PR to submit your idea. The best ideas will be implemented into vanilla Nougaro! If you think that this document is incomplete, that it didn\u2019t help you, or just to find some help, open an issue .","title":"Here you go!"},{"location":"0.22/Language/01syntax/","text":"Very basic syntax This document covers the basic syntax of Nougaro. Comments There are two types of comments in Nougaro: single-line comments and multi-line comments. Single-line comments Single-line comments start with # and end with a new line. They can start at the beginning of a line or after some code. Example: # this is a single-line comment foo(bar) # this calls the function foo with the argument bar Multi-line comments Multi-line comments start with /* and end with */ . They can start and stop at any point in the code. Example: /* this is a multi line comment */ print(\"hello\") /* this is also a multi line comment*/ Multi-line comments can also be only on one line: print(\"hello\") /* this is a multi-line comment that is only on one line */ Multi-line comments are simply ignored, which mean you can do things such as: print( /* this is a comment */ \"hello\" /* this is another comment */) print(/* this is actually a comment*/ \"hello\") Multi-line comments can be nested: /* comment /* comment-inside comment*/ /* /* comment-ception */ */ comment */ Lines Line are separated by a newline or a semicolon ( ; ). a b is equivalent to a ; b . Line joining If you don\u2019t have enough space on your line, you can join two \u201creal lines\u201d to form a Nougaro line, using a backspace. Example: var fruits = [\\ \"banana\", \\ \"apple\", \\ \"raspberry\", \\ \"pineapple\" \\ ] Blank lines Blank lines are ignored. Indentation Indentation is optional, as (mostly) every statement ends with end . Whitespaces Whitespaces are ignored everywhere (except in string literals and to differentiate things such as foobar and foo bar , or += and + = ).","title":"Very basic syntax"},{"location":"0.22/Language/01syntax/#very-basic-syntax","text":"This document covers the basic syntax of Nougaro.","title":"Very basic syntax"},{"location":"0.22/Language/01syntax/#comments","text":"There are two types of comments in Nougaro: single-line comments and multi-line comments.","title":"Comments"},{"location":"0.22/Language/01syntax/#single-line-comments","text":"Single-line comments start with # and end with a new line. They can start at the beginning of a line or after some code. Example: # this is a single-line comment foo(bar) # this calls the function foo with the argument bar","title":"Single-line comments"},{"location":"0.22/Language/01syntax/#multi-line-comments","text":"Multi-line comments start with /* and end with */ . They can start and stop at any point in the code. Example: /* this is a multi line comment */ print(\"hello\") /* this is also a multi line comment*/ Multi-line comments can also be only on one line: print(\"hello\") /* this is a multi-line comment that is only on one line */ Multi-line comments are simply ignored, which mean you can do things such as: print( /* this is a comment */ \"hello\" /* this is another comment */) print(/* this is actually a comment*/ \"hello\") Multi-line comments can be nested: /* comment /* comment-inside comment*/ /* /* comment-ception */ */ comment */","title":"Multi-line comments"},{"location":"0.22/Language/01syntax/#lines","text":"Line are separated by a newline or a semicolon ( ; ). a b is equivalent to a ; b .","title":"Lines"},{"location":"0.22/Language/01syntax/#line-joining","text":"If you don\u2019t have enough space on your line, you can join two \u201creal lines\u201d to form a Nougaro line, using a backspace. Example: var fruits = [\\ \"banana\", \\ \"apple\", \\ \"raspberry\", \\ \"pineapple\" \\ ]","title":"Line joining"},{"location":"0.22/Language/01syntax/#blank-lines","text":"Blank lines are ignored.","title":"Blank lines"},{"location":"0.22/Language/01syntax/#indentation","text":"Indentation is optional, as (mostly) every statement ends with end .","title":"Indentation"},{"location":"0.22/Language/01syntax/#whitespaces","text":"Whitespaces are ignored everywhere (except in string literals and to differentiate things such as foobar and foo bar , or += and + = ).","title":"Whitespaces"},{"location":"0.22/Language/02number_literals/","text":"Number literals Here\u2019s all the different ways to write a number in Nougaro: 123 12.3 123e2 12.3e2 123e-2 123e+2 12.3e-2 12.3e+2 Note You can put + or - in front of the number to specify its sign. Example: -123 . Other bases: 0b01110 (base 2, binary) 0o17403 (base 8, octal) 0x4EF1A (base 16, hexadecimal) 0b10e30 0o70e30 Note 0xA0e30 will be interpreted as the hexadecimal number A0E30 ( 3*16^1 + 15*16^2 + 10*16^4 ) and not as 0xA0 * 10^30 _ in numbers Note You can put as much underscores ( _ ) as you want in a number literal, as long as the underscore are not at the beginning or at the end of the literal, or around the dot in floating-point numbers (ex: 10_694_254 is the same as 10694254 , 10_ is not valid, 12._3 is not valid and 12_._3 isn\u2019t either.)","title":"Number literals"},{"location":"0.22/Language/02number_literals/#number-literals","text":"Here\u2019s all the different ways to write a number in Nougaro: 123 12.3 123e2 12.3e2 123e-2 123e+2 12.3e-2 12.3e+2 Note You can put + or - in front of the number to specify its sign. Example: -123 . Other bases: 0b01110 (base 2, binary) 0o17403 (base 8, octal) 0x4EF1A (base 16, hexadecimal) 0b10e30 0o70e30 Note 0xA0e30 will be interpreted as the hexadecimal number A0E30 ( 3*16^1 + 15*16^2 + 10*16^4 ) and not as 0xA0 * 10^30","title":"Number literals"},{"location":"0.22/Language/02number_literals/#_-in-numbers","text":"Note You can put as much underscores ( _ ) as you want in a number literal, as long as the underscore are not at the beginning or at the end of the literal, or around the dot in floating-point numbers (ex: 10_694_254 is the same as 10694254 , 10_ is not valid, 12._3 is not valid and 12_._3 isn\u2019t either.)","title":"_ in numbers"},{"location":"0.22/Language/03string_literals/","text":"String literals String literals are delimited by \"\" , '' or \u00ab\u00bb . Examples: \"hello\" 'hello' \u00abhello\u00bb Escape characters: \\' : ' \\\" : \" \\\u00bb : \u00bb \\n : backline \\t : tab \\\\ : backslash \\xAA : unicode character number AA (hex) \\uAAAA : unicode character number AAAA (hex) \\UAAAAAAAA : unicode character number AAAAAAAA (hex) \\N{NAME} : unicode character with name NAME. Returns SyntaxError if it doesn\u2019t exist. Note The backslash isn\u2019t left if the next character is not recognised (example: \"\\/\" is the same as \"/\" , and not \"\\\\/\" ) Examples: 'I\\'m a string literal' \"He said: \\\"'I'm a string literal'\\\"\" \"\\\\ backslashes, \\t tabs and \\n backlines\" \u00abThis string has a \\N{NO BREAK SPACE}\u00bb \"\\N{Latin Small Letter C with Cedilla}: \\xe7\" \"\\N{Greek Small Letter Eta with Dasia and Oxia and Ypogegrammeni}: \\u1F95\" \"This is Person Shrugging (\ud83e\udd37): \\U0001f937\" Note You can use the meta nbspBetweenFrenchGuillemets to be forced to use a no-break-space or a narrow-no-break-space after \u00ab and before \u00bb . These NBSP are not counted in the string and this does not affect the other string delimiters.","title":"String literals"},{"location":"0.22/Language/03string_literals/#string-literals","text":"String literals are delimited by \"\" , '' or \u00ab\u00bb . Examples: \"hello\" 'hello' \u00abhello\u00bb Escape characters: \\' : ' \\\" : \" \\\u00bb : \u00bb \\n : backline \\t : tab \\\\ : backslash \\xAA : unicode character number AA (hex) \\uAAAA : unicode character number AAAA (hex) \\UAAAAAAAA : unicode character number AAAAAAAA (hex) \\N{NAME} : unicode character with name NAME. Returns SyntaxError if it doesn\u2019t exist. Note The backslash isn\u2019t left if the next character is not recognised (example: \"\\/\" is the same as \"/\" , and not \"\\\\/\" ) Examples: 'I\\'m a string literal' \"He said: \\\"'I'm a string literal'\\\"\" \"\\\\ backslashes, \\t tabs and \\n backlines\" \u00abThis string has a \\N{NO BREAK SPACE}\u00bb \"\\N{Latin Small Letter C with Cedilla}: \\xe7\" \"\\N{Greek Small Letter Eta with Dasia and Oxia and Ypogegrammeni}: \\u1F95\" \"This is Person Shrugging (\ud83e\udd37): \\U0001f937\" Note You can use the meta nbspBetweenFrenchGuillemets to be forced to use a no-break-space or a narrow-no-break-space after \u00ab and before \u00bb . These NBSP are not counted in the string and this does not affect the other string delimiters.","title":"String literals"},{"location":"0.22/Language/04identifiers_and_keywords/","text":"Identifiers and keywords Identifiers (variable names) can be composed of the 26 characters of the ASCII alphabet ( a to z \u202fthen A to Z ), in lower and upper case, the underscore _ and digits ( 0 to 9 ). Note An identifier can not start with a digit. Keywords The following identifiers are reserved and can not be used as variable names: and as assert break class continue def del do elif else end export for if import in loop not or read return step then to var while write xor","title":"Identifiers and keywords"},{"location":"0.22/Language/04identifiers_and_keywords/#identifiers-and-keywords","text":"Identifiers (variable names) can be composed of the 26 characters of the ASCII alphabet ( a to z \u202fthen A to Z ), in lower and upper case, the underscore _ and digits ( 0 to 9 ). Note An identifier can not start with a digit.","title":"Identifiers and keywords"},{"location":"0.22/Language/04identifiers_and_keywords/#keywords","text":"The following identifiers are reserved and can not be used as variable names: and as assert break class continue def del do elif else end export for if import in loop not or read return step then to var while write xor","title":"Keywords"},{"location":"0.22/Language/05operators/","text":"Operators Mathematical operators Here all the mathematical operators in Nougaro (ordered by priority): Nougaro Python Comments ^ ** power * * multiplication % % modulo / / division // // floor division + + addition - - substraction & & bitwise and | | bitwise or ^^ ^ bitwise xor ~ ~ bitwise not It respects operation priority and you can use parenthesis. Examples 3 * 4 returns 12 4 / 2 returns 2 1 + 1 returns 2 3 - 4 returns -1 10 % 7 returns 3 10 % 3 returns 1 10 // 7 returns 1 10 // 3 returns 3 5 ^ 2 returns 25 62 & 35 returns 34 ~1 returns -2 and ~-2 returns 1 5 + 5 * 3 + 2 returns 22 (5 + 5) * (3 + 2) returns 50 Test operators They are exactly same as Python ones: Nougaro Python Comments == == equals to != != different than < < less than <= <= less than or equals > > greater than >= >= greater than or equals in in check if a value is in another Note the in keyword can check if: int , float , str , list , DefaultValue or NoneValue is in a str any value is in a list Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta. Logical operators There is one logical operator that isn't here in Python. There is a list: Nougaro Python Comments and and boolean 'and' (binary operator) or or boolean 'or' (binary operator) xor ^ boolean 'exclusive or' (binary operator) not not boolean 'not' (inverter) (unary operator)","title":"Operators"},{"location":"0.22/Language/05operators/#operators","text":"","title":"Operators"},{"location":"0.22/Language/05operators/#mathematical-operators","text":"Here all the mathematical operators in Nougaro (ordered by priority): Nougaro Python Comments ^ ** power * * multiplication % % modulo / / division // // floor division + + addition - - substraction & & bitwise and | | bitwise or ^^ ^ bitwise xor ~ ~ bitwise not It respects operation priority and you can use parenthesis.","title":"Mathematical operators"},{"location":"0.22/Language/05operators/#examples","text":"3 * 4 returns 12 4 / 2 returns 2 1 + 1 returns 2 3 - 4 returns -1 10 % 7 returns 3 10 % 3 returns 1 10 // 7 returns 1 10 // 3 returns 3 5 ^ 2 returns 25 62 & 35 returns 34 ~1 returns -2 and ~-2 returns 1 5 + 5 * 3 + 2 returns 22 (5 + 5) * (3 + 2) returns 50","title":"Examples"},{"location":"0.22/Language/05operators/#test-operators","text":"They are exactly same as Python ones: Nougaro Python Comments == == equals to != != different than < < less than <= <= less than or equals > > greater than >= >= greater than or equals in in check if a value is in another Note the in keyword can check if: int , float , str , list , DefaultValue or NoneValue is in a str any value is in a list Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta.","title":"Test operators"},{"location":"0.22/Language/05operators/#logical-operators","text":"There is one logical operator that isn't here in Python. There is a list: Nougaro Python Comments and and boolean 'and' (binary operator) or or boolean 'or' (binary operator) xor ^ boolean 'exclusive or' (binary operator) not not boolean 'not' (inverter) (unary operator)","title":"Logical operators"},{"location":"0.22/Language/06values/","text":"Values Here is the list of the value types in Nougaro: int ( integers ). Internal type: int float ( floats ). Internal type: float str ( strings ). Internal type: str list ( lists ). Internal type: list NoneType ( None ). Internal type: NoneValue function . Internal type: func or method . module . Internal type: module constructor . Internal type: constructor object . Internal type: depends on the class\u2019 name, and it is <class> if the class has no name. Note Internal value types are base value (type: BaseValue ) and default value (type: DefaultValue ) Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta. Changed in 0.22.0-beta Before 0.22.0-beta, a distinction was made between func (user-defined function or function in a module written in Nougaro) and built-in func (built-in function or function in a module written in Python). Numbers Numbers represents real-life numbers. The two types of numbers are int and float . To declare a number, you can use a number literal . Operations that can be used between two numbers are: addition, substraction, multiplication, power. If the second number is non-zero, division, modulo and floor division can be used. All these operations follow the mathematical logic (except for 0^0, that returns 1). Multiplication can be used between a integer (type int ) and a string or a list . For example, 3*\"str\" returns \"strstrstr\" , and 2*[1, 2] returns [1, 2, 1, 2] . In boolean context, a number is true if it is non-zero. Strings The type of a string is str . To declare a string, you can use a string literal The only operation that can be used between strings is addition, which concatenates the string with the other. For example, \"hello, \" + \"world!\" returns \"hello, world!\" . Multiplication can be used between a string and an integer (type int ). For example, \"str\"*3 returns \"strstrstr\" . In boolean context, a string is true if it contains at least one character. Lists Lists are a succession of values. To declare a list, you can use brackets ( [] ), and put every value separated by a comma ( , ) inside. They may be 0 values. To create a list with elements from another list (and other elements), you can use this syntax: [1, 2, *list_, 5] (which is [1, 2, 3, 4, 5] if list_ is [3, 4] ). The only operation that can be used between two lists is multiplication, which extends the first list with the content of the second list. This can also be achieved using extend(list1, list2) Addition can be used between a list and any other value to add an element to the list. Substraction can be used between a list and an integer (type int ) to pop (i.e. delete) an element by index. This supports negative numbers. The returned value is the list after the pop. This can be achieved with pop(list, index) , although this returns the popped value. Multiplication can be used between a list and an integer (type int ). For example, [1, 2]*2 returns [1, 2, 1, 2] . Division can be used between a list and an integer (type int ) to get an element by index. This supports negative numbers. This can be achieved using list(index) or get(list, index) . In boolean context, a list is true if it is not empty None None is a value to denote the absence of other values. It is accessible trought the None built-in variable. No operation can be used on None . In boolean context, None is false. Modules A module is a value containing various useful functions and constants. A list of modules can be found here . Importing modules is detailed here . The procedure to create your own module is detailed here . No operation can be used on modules. In boolean context, a module is true. Changed in 0.22.0-beta Prior to 0.22.0-beta, a module was false in boolean context.","title":"Values"},{"location":"0.22/Language/06values/#values","text":"Here is the list of the value types in Nougaro: int ( integers ). Internal type: int float ( floats ). Internal type: float str ( strings ). Internal type: str list ( lists ). Internal type: list NoneType ( None ). Internal type: NoneValue function . Internal type: func or method . module . Internal type: module constructor . Internal type: constructor object . Internal type: depends on the class\u2019 name, and it is <class> if the class has no name. Note Internal value types are base value (type: BaseValue ) and default value (type: DefaultValue ) Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta. Changed in 0.22.0-beta Before 0.22.0-beta, a distinction was made between func (user-defined function or function in a module written in Nougaro) and built-in func (built-in function or function in a module written in Python).","title":"Values"},{"location":"0.22/Language/06values/#numbers","text":"Numbers represents real-life numbers. The two types of numbers are int and float . To declare a number, you can use a number literal . Operations that can be used between two numbers are: addition, substraction, multiplication, power. If the second number is non-zero, division, modulo and floor division can be used. All these operations follow the mathematical logic (except for 0^0, that returns 1). Multiplication can be used between a integer (type int ) and a string or a list . For example, 3*\"str\" returns \"strstrstr\" , and 2*[1, 2] returns [1, 2, 1, 2] . In boolean context, a number is true if it is non-zero.","title":"Numbers"},{"location":"0.22/Language/06values/#strings","text":"The type of a string is str . To declare a string, you can use a string literal The only operation that can be used between strings is addition, which concatenates the string with the other. For example, \"hello, \" + \"world!\" returns \"hello, world!\" . Multiplication can be used between a string and an integer (type int ). For example, \"str\"*3 returns \"strstrstr\" . In boolean context, a string is true if it contains at least one character.","title":"Strings"},{"location":"0.22/Language/06values/#lists","text":"Lists are a succession of values. To declare a list, you can use brackets ( [] ), and put every value separated by a comma ( , ) inside. They may be 0 values. To create a list with elements from another list (and other elements), you can use this syntax: [1, 2, *list_, 5] (which is [1, 2, 3, 4, 5] if list_ is [3, 4] ). The only operation that can be used between two lists is multiplication, which extends the first list with the content of the second list. This can also be achieved using extend(list1, list2) Addition can be used between a list and any other value to add an element to the list. Substraction can be used between a list and an integer (type int ) to pop (i.e. delete) an element by index. This supports negative numbers. The returned value is the list after the pop. This can be achieved with pop(list, index) , although this returns the popped value. Multiplication can be used between a list and an integer (type int ). For example, [1, 2]*2 returns [1, 2, 1, 2] . Division can be used between a list and an integer (type int ) to get an element by index. This supports negative numbers. This can be achieved using list(index) or get(list, index) . In boolean context, a list is true if it is not empty","title":"Lists"},{"location":"0.22/Language/06values/#none","text":"None is a value to denote the absence of other values. It is accessible trought the None built-in variable. No operation can be used on None . In boolean context, None is false.","title":"None"},{"location":"0.22/Language/06values/#modules","text":"A module is a value containing various useful functions and constants. A list of modules can be found here . Importing modules is detailed here . The procedure to create your own module is detailed here . No operation can be used on modules. In boolean context, a module is true. Changed in 0.22.0-beta Prior to 0.22.0-beta, a module was false in boolean context.","title":"Modules"},{"location":"0.22/Language/07variables/","text":"Variables Definition Use the syntax var identifier = value (see identifiers and values ) to assign the value value to the variable named identifier . The expression var identifier = value returns value . To assign the same value to multiple variables, you can use var variable1 = var variable2 = var variable3 = value . If you want to assign multiple values to multiple variables, you can use var variable1, variable2 = value1, value2 . This can be used to swap variables: var a, b = b, a . Except for keywords , there are no prohibited variable name. Edition You can edit variables by multiple ways: var a = value ; var a += value : same as var a = a + value ; var a ++ : same as var a += 1 ; var a -= value : same as var a = a - value ; var a -- : same as var a -= 1 ; var a *= value : same as var a = a * value ; var a /= value : same as var a = a / value ; var a ^= value : same as var a = a ^ value ; var a //= value : same as var a = a // value ; var a %= value : same as var a = a % value ; var a ||= value : same as var a = a or value ; var a &&= value : same as var a = a and value ; var a ^^^= value : same as var a = a xor value ; var a |= value : same as var a = a | value ; var a &= value : same as var a = a & value ; var a ^^= value : same as var a = a ^^ value ; var a === value : same as var a = a == value ; var a <== value : same as var a = a <= value ; var a <<= value : same as var a = a < value ; var a >== value : same as var a = a >= value ; var a >>= value : same as var a = a > value . Info For details about these operators, see this page . Note You can also edit multiple variables at the same time: var a, b += 1, 2 : same as var a += 1 ; var b += 2 var a, b ++ : same as var a, b += 1, 1 var a, b //= b, a : same as var c = a ; var a //= b ; var b //= c ; del c Access To access to a variable, you can: give the identifier: foo (returns the value of foo ) use the special syntax: foo ? bar ? a ? b (returns the value of foo if it is defined, otherwise the value of bar ... You can put as much ? identifier as you want.) Then, you can put an expression at the end, such as 2 . In this case, the value returned will be 2 if none of the given identifiers is defined. Deletion If you don't need a variable anymore, you can delete it with the del keyword: del identifier . Examples var foo = var bar = 12 while foo != bar - 1 then var bar -= 1 (see while loop ) Example for deletion Create a variable a , the delete it: nougaro> var a = 1 1 nougaro> del a But be careful! It can return errors: nougaro> var a = 1 1 nougaro> del a nougaro> del a Traceback (more recent call last): In file <stdin>, line 1, in <program>: del a ^ NotDefinedError: a is not defined.","title":"Variables"},{"location":"0.22/Language/07variables/#variables","text":"","title":"Variables"},{"location":"0.22/Language/07variables/#definition","text":"Use the syntax var identifier = value (see identifiers and values ) to assign the value value to the variable named identifier . The expression var identifier = value returns value . To assign the same value to multiple variables, you can use var variable1 = var variable2 = var variable3 = value . If you want to assign multiple values to multiple variables, you can use var variable1, variable2 = value1, value2 . This can be used to swap variables: var a, b = b, a . Except for keywords , there are no prohibited variable name.","title":"Definition"},{"location":"0.22/Language/07variables/#edition","text":"You can edit variables by multiple ways: var a = value ; var a += value : same as var a = a + value ; var a ++ : same as var a += 1 ; var a -= value : same as var a = a - value ; var a -- : same as var a -= 1 ; var a *= value : same as var a = a * value ; var a /= value : same as var a = a / value ; var a ^= value : same as var a = a ^ value ; var a //= value : same as var a = a // value ; var a %= value : same as var a = a % value ; var a ||= value : same as var a = a or value ; var a &&= value : same as var a = a and value ; var a ^^^= value : same as var a = a xor value ; var a |= value : same as var a = a | value ; var a &= value : same as var a = a & value ; var a ^^= value : same as var a = a ^^ value ; var a === value : same as var a = a == value ; var a <== value : same as var a = a <= value ; var a <<= value : same as var a = a < value ; var a >== value : same as var a = a >= value ; var a >>= value : same as var a = a > value . Info For details about these operators, see this page . Note You can also edit multiple variables at the same time: var a, b += 1, 2 : same as var a += 1 ; var b += 2 var a, b ++ : same as var a, b += 1, 1 var a, b //= b, a : same as var c = a ; var a //= b ; var b //= c ; del c","title":"Edition"},{"location":"0.22/Language/07variables/#access","text":"To access to a variable, you can: give the identifier: foo (returns the value of foo ) use the special syntax: foo ? bar ? a ? b (returns the value of foo if it is defined, otherwise the value of bar ... You can put as much ? identifier as you want.) Then, you can put an expression at the end, such as 2 . In this case, the value returned will be 2 if none of the given identifiers is defined.","title":"Access"},{"location":"0.22/Language/07variables/#deletion","text":"If you don't need a variable anymore, you can delete it with the del keyword: del identifier .","title":"Deletion"},{"location":"0.22/Language/07variables/#examples","text":"var foo = var bar = 12 while foo != bar - 1 then var bar -= 1 (see while loop )","title":"Examples"},{"location":"0.22/Language/07variables/#example-for-deletion","text":"Create a variable a , the delete it: nougaro> var a = 1 1 nougaro> del a But be careful! It can return errors: nougaro> var a = 1 1 nougaro> del a nougaro> del a Traceback (more recent call last): In file <stdin>, line 1, in <program>: del a ^ NotDefinedError: a is not defined.","title":"Example for deletion"},{"location":"0.22/Language/08tests/","text":"Test statements List There is the list of test keywords in Nougaro : Nougaro Python if if then : elif elif else else Syntax if <cond> then <expr> if <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> else <expr> etc. Multi-line : if <cond> then <some code here> end if <cond> then <some code here> else <some other code> end if <cond> then <some code here> else <some other code> end etc. Behaviour The condition is checked. If it is true, the expression in the if branch is executed. Otherwise, Nougaro checks for an elif branch. If it exists, it re-checks the condition, etc. If none of the conditions is true and that there is an else branch, the expression in the else branch is executed. If there is no else branch, nothing is executed. Logicals constants Nougaro Python Comments True True equals to 1 False False equals to 0 Conditions Conditions can be any value , which will be interpreted in its boolean context. Conditions can also use test operators . For instance, a == b checks if a is equal to b , where a < b checks if a is strictly less than b .\u202fYou can chain multiple operators: a == b <= c != d checks if a is equal to b and if b is less than or equal to c and if c is different from d . Multiple conditions can be combined with boolean/logical operators . Here is the truth table of the logical operators: and a b a and b 0 0 0 0 1 0 1 0 0 1 1 1 or a b a or b 0 0 0 0 1 1 1 0 1 1 1 1 xor a b a xor b 0 0 0 0 1 1 1 0 1 1 1 0 not a not a 0 1 1 0 There is no priority amongst boolean operators, so for instance a and b or c xor d gives ((a and b) or c) xor d . After interpretation, a condition is always 0 or 1 ( False or True ). Examples if foo == bar then var foo = 12 if bar != foo then var foo = 12 else var bar = 13 * if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 end if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 else var foo = 12 end","title":"Test statements"},{"location":"0.22/Language/08tests/#test-statements","text":"","title":"Test statements"},{"location":"0.22/Language/08tests/#list","text":"There is the list of test keywords in Nougaro : Nougaro Python if if then : elif elif else else","title":"List"},{"location":"0.22/Language/08tests/#syntax","text":"if <cond> then <expr> if <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> else <expr> etc. Multi-line : if <cond> then <some code here> end if <cond> then <some code here> else <some other code> end if <cond> then <some code here> else <some other code> end etc.","title":"Syntax"},{"location":"0.22/Language/08tests/#behaviour","text":"The condition is checked. If it is true, the expression in the if branch is executed. Otherwise, Nougaro checks for an elif branch. If it exists, it re-checks the condition, etc. If none of the conditions is true and that there is an else branch, the expression in the else branch is executed. If there is no else branch, nothing is executed.","title":"Behaviour"},{"location":"0.22/Language/08tests/#logicals-constants","text":"Nougaro Python Comments True True equals to 1 False False equals to 0","title":"Logicals constants"},{"location":"0.22/Language/08tests/#conditions","text":"Conditions can be any value , which will be interpreted in its boolean context. Conditions can also use test operators . For instance, a == b checks if a is equal to b , where a < b checks if a is strictly less than b .\u202fYou can chain multiple operators: a == b <= c != d checks if a is equal to b and if b is less than or equal to c and if c is different from d . Multiple conditions can be combined with boolean/logical operators . Here is the truth table of the logical operators:","title":"Conditions"},{"location":"0.22/Language/08tests/#and","text":"a b a and b 0 0 0 0 1 0 1 0 0 1 1 1","title":"and"},{"location":"0.22/Language/08tests/#or","text":"a b a or b 0 0 0 0 1 1 1 0 1 1 1 1","title":"or"},{"location":"0.22/Language/08tests/#xor","text":"a b a xor b 0 0 0 0 1 1 1 0 1 1 1 0","title":"xor"},{"location":"0.22/Language/08tests/#not","text":"a not a 0 1 1 0 There is no priority amongst boolean operators, so for instance a and b or c xor d gives ((a and b) or c) xor d . After interpretation, a condition is always 0 or 1 ( False or True ).","title":"not"},{"location":"0.22/Language/08tests/#examples","text":"if foo == bar then var foo = 12 if bar != foo then var foo = 12 else var bar = 13 * if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 end if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 else var foo = 12 end","title":"Examples"},{"location":"0.22/Language/09loops/","text":"Loops Loops are made to execute the same piece of code multiple times in a row. Here is a list of available loops in Nougaro: Nougaro Python C/C++ for for for while while while do ... then loop while (nothing) do ... while for The for loop can have two usages: browse every element in a list (or a str ), or iterate a certain number of times. for each To browse every element in a list (or a str ), use the following syntax: # One line for identifier in list then ... # Multiple lines for identifier in list then ... ... end For each element of the list, the variable identifier will be set to the corresponding element, and this variable can be used inside the loop. for i = ... to ... # One line for identifier = start_value to end_value then ... for identifier = start_value to end_value step step_value then ... # Multiple lines for identifier = start_value to end_value then ... ... end for identifier = start_value to end_value step step_value then ... ... end start_value , end_value and step_value are integers . If step_value is not specified, the default value is 0. This loop starts by setting the variable identifier to start_value , then executes the loop. It then adds step_value to identifier . If the value of identifier is greater than or equal to end_value , the loops stops without executing. Otherwise, it runs until this condition is reached. Note In for loops, the start value can be less than the end value. In that case, don\u2019t forget to give a negative step! while The while loop is used to repeat a piece of code as long as a condition is met. It has the following syntax: # One line while condition then ... # Multiple lines while condition then ... ... end do The do loop is used to execute a piece of code a first time, then repeat it as long as a condition is met. It has the following syntax: # One line do ... then loop while condition # Multiple lines do ... ... then loop while condition Labels Added in 0.20.0-beta Labels were added in 0.20.0-beta. You can label a loop using for:label , while:label or do:label . Labels are identifiers . You can use labels with break and continue . break , continue Changed in 0.20.0-beta Prior to 0.20.0-beta, break and continue did append None to the return list. To re-enable this behaviour, you can enable appendNoneOnBreak or appendNoneOnContinue metas . Added in 0.20.0-beta Labels were added in 0.20.0-beta. The break statement completely stops the loop. If there is a returned list, the value is not added to this list. You can use break and return ... to return a specific value. The continue statement omit the code after it, and execute another time the loop like if the last time was ended. continue and break work normally at the first execution of a do body. continue:label will continue the loop that has this label. If you\u2019re in an :inner loop inside a :label loop, the :inner loop will break and the :label loop will continue. break:label will break the loop that has this label. If you\u2019re in an :inner loop inside a :label loop, the :inner AND the :label loop will break.","title":"Loops"},{"location":"0.22/Language/09loops/#loops","text":"Loops are made to execute the same piece of code multiple times in a row. Here is a list of available loops in Nougaro: Nougaro Python C/C++ for for for while while while do ... then loop while (nothing) do ... while","title":"Loops"},{"location":"0.22/Language/09loops/#for","text":"The for loop can have two usages: browse every element in a list (or a str ), or iterate a certain number of times.","title":"for"},{"location":"0.22/Language/09loops/#for-each","text":"To browse every element in a list (or a str ), use the following syntax: # One line for identifier in list then ... # Multiple lines for identifier in list then ... ... end For each element of the list, the variable identifier will be set to the corresponding element, and this variable can be used inside the loop.","title":"for each"},{"location":"0.22/Language/09loops/#for-i-to","text":"# One line for identifier = start_value to end_value then ... for identifier = start_value to end_value step step_value then ... # Multiple lines for identifier = start_value to end_value then ... ... end for identifier = start_value to end_value step step_value then ... ... end start_value , end_value and step_value are integers . If step_value is not specified, the default value is 0. This loop starts by setting the variable identifier to start_value , then executes the loop. It then adds step_value to identifier . If the value of identifier is greater than or equal to end_value , the loops stops without executing. Otherwise, it runs until this condition is reached. Note In for loops, the start value can be less than the end value. In that case, don\u2019t forget to give a negative step!","title":"for i = ... to ..."},{"location":"0.22/Language/09loops/#while","text":"The while loop is used to repeat a piece of code as long as a condition is met. It has the following syntax: # One line while condition then ... # Multiple lines while condition then ... ... end","title":"while"},{"location":"0.22/Language/09loops/#do","text":"The do loop is used to execute a piece of code a first time, then repeat it as long as a condition is met. It has the following syntax: # One line do ... then loop while condition # Multiple lines do ... ... then loop while condition","title":"do"},{"location":"0.22/Language/09loops/#labels","text":"Added in 0.20.0-beta Labels were added in 0.20.0-beta. You can label a loop using for:label , while:label or do:label . Labels are identifiers . You can use labels with break and continue .","title":"Labels"},{"location":"0.22/Language/09loops/#break-continue","text":"Changed in 0.20.0-beta Prior to 0.20.0-beta, break and continue did append None to the return list. To re-enable this behaviour, you can enable appendNoneOnBreak or appendNoneOnContinue metas . Added in 0.20.0-beta Labels were added in 0.20.0-beta. The break statement completely stops the loop. If there is a returned list, the value is not added to this list. You can use break and return ... to return a specific value. The continue statement omit the code after it, and execute another time the loop like if the last time was ended. continue and break work normally at the first execution of a do body. continue:label will continue the loop that has this label. If you\u2019re in an :inner loop inside a :label loop, the :inner loop will break and the :label loop will continue. break:label will break the loop that has this label. If you\u2019re in an :inner loop inside a :label loop, the :inner AND the :label loop will break.","title":"break, continue"},{"location":"0.22/Language/10functions/","text":"Functions Internal type: func . No operation can be used on functions. Functions are true in boolean context. Changed in 0.22.0-beta Prior to 0.22.0-beta, functions were false in boolean context. Definition To define a function, use the def keyword and an arrow: def name(param1, param2) -> <some code here> . You can omit the name, but in this case you have to call directly the function or to store it in a variable: (def (param1) -> <some code here>)(<arg1>) ; var somefunc = def (param1) -> <some code here> You can define multi-line functions: def name(param1, param2, param3) <some code here> end Note The arguments given and the variables created inside the function are deleted at the end of the function execution. Similarly, the variables created outside the function and before its definition are accessible inside the function, but modifications are not saved. Info There can be 0 parameters. Optional parameters Note Added in 0.22.0-beta To define optional parameters, use this syntax: def name(param1, param2, param3)(optional_param1=default_value, optional_param2=default_value) <some code here> end return statement In the code executed by your function, there can be the return statement. It stops the function. If a value is placed after the statement, the function will return this value when called. In the other cases, it will return None . Call Call a function using this syntax: func(arg1, arg2) You can store arguments in a list and use *list . E.g. func(*list_) , func(*[1, 2, 3]) . Optional arguments Note Added in 0.22.0-beta You can omit optional arguments, which will set them to their default value. In this case: def name(param1, param2, param3)(optional_param1=default_value, optional_param2=default_value) , if you want to keep optional_param1 to its default value but not optional_param2 , you can use: name(argument1, argument2, argument3, <default>, optional_argument2) (keep < and > around <default> ) Examples def foo(a, b) -> a*b - b def bar(a, b) -> (a-1)*b var c = 2 var d = 5 if foo(c, d) == bar(c, d) then var e = True else var e = False (In this case, e = 1) def foo(a, b) if a == 2 then return a + b else return b end end def foo(a, b)(should_return_none = False) if a == 2 then return a + b else if should_return_none then return return b end end foo(1, 5) # 5 foo(2, 5) # 7 foo(1, 5, <default>) # 5 foo(2, 5, <default>) # 7 foo(1, 5, True) # None foo(2, 5, True) # 7","title":"Functions"},{"location":"0.22/Language/10functions/#functions","text":"Internal type: func . No operation can be used on functions. Functions are true in boolean context. Changed in 0.22.0-beta Prior to 0.22.0-beta, functions were false in boolean context.","title":"Functions"},{"location":"0.22/Language/10functions/#definition","text":"To define a function, use the def keyword and an arrow: def name(param1, param2) -> <some code here> . You can omit the name, but in this case you have to call directly the function or to store it in a variable: (def (param1) -> <some code here>)(<arg1>) ; var somefunc = def (param1) -> <some code here> You can define multi-line functions: def name(param1, param2, param3) <some code here> end Note The arguments given and the variables created inside the function are deleted at the end of the function execution. Similarly, the variables created outside the function and before its definition are accessible inside the function, but modifications are not saved. Info There can be 0 parameters.","title":"Definition"},{"location":"0.22/Language/10functions/#optional-parameters","text":"Note Added in 0.22.0-beta To define optional parameters, use this syntax: def name(param1, param2, param3)(optional_param1=default_value, optional_param2=default_value) <some code here> end","title":"Optional parameters"},{"location":"0.22/Language/10functions/#return-statement","text":"In the code executed by your function, there can be the return statement. It stops the function. If a value is placed after the statement, the function will return this value when called. In the other cases, it will return None .","title":"return statement"},{"location":"0.22/Language/10functions/#call","text":"Call a function using this syntax: func(arg1, arg2) You can store arguments in a list and use *list . E.g. func(*list_) , func(*[1, 2, 3]) .","title":"Call"},{"location":"0.22/Language/10functions/#optional-arguments","text":"Note Added in 0.22.0-beta You can omit optional arguments, which will set them to their default value. In this case: def name(param1, param2, param3)(optional_param1=default_value, optional_param2=default_value) , if you want to keep optional_param1 to its default value but not optional_param2 , you can use: name(argument1, argument2, argument3, <default>, optional_argument2) (keep < and > around <default> )","title":"Optional arguments"},{"location":"0.22/Language/10functions/#examples","text":"def foo(a, b) -> a*b - b def bar(a, b) -> (a-1)*b var c = 2 var d = 5 if foo(c, d) == bar(c, d) then var e = True else var e = False (In this case, e = 1) def foo(a, b) if a == 2 then return a + b else return b end end def foo(a, b)(should_return_none = False) if a == 2 then return a + b else if should_return_none then return return b end end foo(1, 5) # 5 foo(2, 5) # 7 foo(1, 5, <default>) # 5 foo(2, 5, <default>) # 7 foo(1, 5, True) # None foo(2, 5, True) # 7","title":"Examples"},{"location":"0.22/Language/11attributes/","text":"Attributes Values in Nougaro can have attributes, i.e. subvalues that have a name. They can be set using the classical variable definition syntax: var variable.attribute = value They can be accessed using the dot-syntax: variable.attribute Note You can even access any name defined in the context of the value. For instance, variable.print references the print built-in function. Pro tip The next time you have a bug, document it. If it is documented, it is therefore not a bug.","title":"Attributes"},{"location":"0.22/Language/11attributes/#attributes","text":"Values in Nougaro can have attributes, i.e. subvalues that have a name. They can be set using the classical variable definition syntax: var variable.attribute = value They can be accessed using the dot-syntax: variable.attribute Note You can even access any name defined in the context of the value. For instance, variable.print references the print built-in function. Pro tip The next time you have a bug, document it. If it is documented, it is therefore not a bug.","title":"Attributes"},{"location":"0.22/Language/12classes/","text":"Classes and objects Note Added in 0.15-beta Nougaro is an object-oriented programming language, which means you can create objects using classes . Class definition To define a class, use this syntax: class Name ... end To create attributes , just use the basic var id = value syntax: class Name var a = 3 var b = 1 end To create methods , just use the basic def syntax . Access to object\u2019s attributes with this : class Name var a = 3 var b = 1 def increment_b(by) var this.b += 1 end def get_a() return this.a end end Methods are attributes themselves. Methods Internal type: method . No operation can be used on methods. Methods are true in boolean context. Changed in 0.22.0-beta Prior to 0.22.0-beta, methods were false in boolean context. Constructor value Internal type: constructor . No operation can be used on constructors. Constructors are false in boolean context. Inheritance To inherit from another class, use the class Name(Iherit) syntax: class ChildOfName(Name) var c = 3 def set_c(new_value) var this.c = new_value end def a_plus_b_plus_c() return this.get_a() + this.b + this.c end end Object Classes can be instanced into objects by calling them. Example: var instance = Name() instance.increment_b(10) assert instance.b == 11 Example See the stack.noug example located in ./examples/ in the main Nougaro repository.","title":"Classes and objects"},{"location":"0.22/Language/12classes/#classes-and-objects","text":"Note Added in 0.15-beta Nougaro is an object-oriented programming language, which means you can create objects using classes .","title":"Classes and objects"},{"location":"0.22/Language/12classes/#class-definition","text":"To define a class, use this syntax: class Name ... end To create attributes , just use the basic var id = value syntax: class Name var a = 3 var b = 1 end To create methods , just use the basic def syntax . Access to object\u2019s attributes with this : class Name var a = 3 var b = 1 def increment_b(by) var this.b += 1 end def get_a() return this.a end end Methods are attributes themselves.","title":"Class definition"},{"location":"0.22/Language/12classes/#methods","text":"Internal type: method . No operation can be used on methods. Methods are true in boolean context. Changed in 0.22.0-beta Prior to 0.22.0-beta, methods were false in boolean context.","title":"Methods"},{"location":"0.22/Language/12classes/#constructor-value","text":"Internal type: constructor . No operation can be used on constructors. Constructors are false in boolean context.","title":"Constructor value"},{"location":"0.22/Language/12classes/#inheritance","text":"To inherit from another class, use the class Name(Iherit) syntax: class ChildOfName(Name) var c = 3 def set_c(new_value) var this.c = new_value end def a_plus_b_plus_c() return this.get_a() + this.b + this.c end end","title":"Inheritance"},{"location":"0.22/Language/12classes/#object","text":"Classes can be instanced into objects by calling them. Example: var instance = Name() instance.increment_b(10) assert instance.b == 11","title":"Object"},{"location":"0.22/Language/12classes/#example","text":"See the stack.noug example located in ./examples/ in the main Nougaro repository.","title":"Example"},{"location":"0.22/Language/13read_and_write_files/","text":"Read and write in files Read To read a file, use read \"path/to/file.ext\" or read \"path/to/file\" line_number . You can assign this value to a variable by using read \"file\" >> identifier line_number or var identifier = read \"file\" line_number . line_number is an integer and is optional. You can use \"<stdin>\" as file name to get a line of input from the user. It is exactly like the input built-in function . The read expression returns the content of the file (or of the line). Write To write in a file, use write \"sometext\" >> \"path/to/file.ext\" line_number . line_number is an integer and is optional. To overwrite the content when you write, replace >> by !>> . You can use \"<stdout>\" as file name to print a text in the console. It is exactly like the print built-in function . If you overwrite the contents of <stdout> , the console is cleared (exactly like the clear built-in function .) The write expression returns the text that was wrote in the file.","title":"Read and write in files"},{"location":"0.22/Language/13read_and_write_files/#read-and-write-in-files","text":"","title":"Read and write in files"},{"location":"0.22/Language/13read_and_write_files/#read","text":"To read a file, use read \"path/to/file.ext\" or read \"path/to/file\" line_number . You can assign this value to a variable by using read \"file\" >> identifier line_number or var identifier = read \"file\" line_number . line_number is an integer and is optional. You can use \"<stdin>\" as file name to get a line of input from the user. It is exactly like the input built-in function . The read expression returns the content of the file (or of the line).","title":"Read"},{"location":"0.22/Language/13read_and_write_files/#write","text":"To write in a file, use write \"sometext\" >> \"path/to/file.ext\" line_number . line_number is an integer and is optional. To overwrite the content when you write, replace >> by !>> . You can use \"<stdout>\" as file name to print a text in the console. It is exactly like the print built-in function . If you overwrite the contents of <stdout> , the console is cleared (exactly like the clear built-in function .) The write expression returns the text that was wrote in the file.","title":"Write"},{"location":"0.22/Language/14import/","text":"Import and export import and export are two keywords related to modules /libraries. Import The import keyword is used to import a module in the current code. It follows the syntax import name or import name as alias . It checks for name in Nougaro stardard library and in the current directory for a file named name.noug . dir.subdir.name looks for ./dir/subdir/name.noug . Note: the current directory is the directory of the file that were executed. For instance, if the file foo.noug (in the directory project ) imported dir.bar , and that dir/bar.noug has import name , name is checked in the project directory. The import keyword created a module value with, as attributes, all the values exported by the module. Export The export keyword is used to export a value in a module, that will become an attribute of the module\u2019s value when imported. It follows the syntax export name or export expression as name . More in this page .","title":"Import and export"},{"location":"0.22/Language/14import/#import-and-export","text":"import and export are two keywords related to modules /libraries.","title":"Import and export"},{"location":"0.22/Language/14import/#import","text":"The import keyword is used to import a module in the current code. It follows the syntax import name or import name as alias . It checks for name in Nougaro stardard library and in the current directory for a file named name.noug . dir.subdir.name looks for ./dir/subdir/name.noug . Note: the current directory is the directory of the file that were executed. For instance, if the file foo.noug (in the directory project ) imported dir.bar , and that dir/bar.noug has import name , name is checked in the project directory. The import keyword created a module value with, as attributes, all the values exported by the module.","title":"Import"},{"location":"0.22/Language/14import/#export","text":"The export keyword is used to export a value in a module, that will become an attribute of the module\u2019s value when imported. It follows the syntax export name or export expression as name . More in this page .","title":"Export"},{"location":"0.22/Language/15metas/","text":"Metas Note Added in 0.19.0-beta Metas are a way to use other (or old) functionnalities in Nougaro. They\u2019re used by adding @meta metaName or @meta metaName value at the beginning of a file or in an interactive shell. Note that, instead of @ , you can use any of those prefixes: #@ , %@ , @@ , -@ , $@ . appendNoneOnBreak Note Added in 0.20.0-beta If enabled, this meta forces a break statement to append None to the list returned by the loop . appendNoneOnContinue Note Added in 0.20.0-beta If enabled, this meta forces a continue statement to append None to the list returned by the loop . legacyAbs The legacyAbs meta lets you use the old syntax (in the prototype-1 version) for absolute value, which is |...| . However, this meta disables the bitwise or operation . Example: @meta legacyAbs print(|-1|) # 1 var a = 12 print(|-a|) # 12 nbspBetweenFrenchGuillemets The nbspBetweenFrenchGuillemets meta requires you, if you use the french string quotes ( \u00ab\u00bb ), to put a no-break space (or a narrow no-break space) after the \u00ab and before the \u00bb . Example: @meta nbspBetweenFrenchGuillemets print(\u00ab hello, world \u00bb) /* hello, world * note that the quotes aren\u2019t regular spaces */ setTheTestValueTo Sets __the_test_value__ to the str value given in the meta value If no value is given, it sets it to None .","title":"Metas"},{"location":"0.22/Language/15metas/#metas","text":"Note Added in 0.19.0-beta Metas are a way to use other (or old) functionnalities in Nougaro. They\u2019re used by adding @meta metaName or @meta metaName value at the beginning of a file or in an interactive shell. Note that, instead of @ , you can use any of those prefixes: #@ , %@ , @@ , -@ , $@ .","title":"Metas"},{"location":"0.22/Language/15metas/#appendnoneonbreak","text":"Note Added in 0.20.0-beta If enabled, this meta forces a break statement to append None to the list returned by the loop .","title":"appendNoneOnBreak"},{"location":"0.22/Language/15metas/#appendnoneoncontinue","text":"Note Added in 0.20.0-beta If enabled, this meta forces a continue statement to append None to the list returned by the loop .","title":"appendNoneOnContinue"},{"location":"0.22/Language/15metas/#legacyabs","text":"The legacyAbs meta lets you use the old syntax (in the prototype-1 version) for absolute value, which is |...| . However, this meta disables the bitwise or operation . Example: @meta legacyAbs print(|-1|) # 1 var a = 12 print(|-a|) # 12","title":"legacyAbs"},{"location":"0.22/Language/15metas/#nbspbetweenfrenchguillemets","text":"The nbspBetweenFrenchGuillemets meta requires you, if you use the french string quotes ( \u00ab\u00bb ), to put a no-break space (or a narrow no-break space) after the \u00ab and before the \u00bb . Example: @meta nbspBetweenFrenchGuillemets print(\u00ab hello, world \u00bb) /* hello, world * note that the quotes aren\u2019t regular spaces */","title":"nbspBetweenFrenchGuillemets"},{"location":"0.22/Language/15metas/#setthetestvalueto","text":"Sets __the_test_value__ to the str value given in the meta value If no value is given, it sets it to None .","title":"setTheTestValueTo"},{"location":"0.22/stdlib/01builtin-variables/","text":"","title":"01builtin variables"},{"location":"0.22/stdlib/02builtin-functions/","text":"","title":"02builtin functions"},{"location":"0.22/stdlib/modules/","text":"Modules","title":"Modules"},{"location":"0.22/stdlib/modules/#modules","text":"","title":"Modules"}]}