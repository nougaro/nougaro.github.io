{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Nougaro documentation Warning This documentation is a work-in-progress and is not actually the most up-to-date source of information. For the actual documentation (that will soon be moved here), see the wiki Overview Nougaro is an interpreted dynamic-typed programming language. Choose your version 0.22 License This document is under the GNU FDL licence. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\".","title":"Welcome to the Nougaro documentation"},{"location":"#welcome-to-the-nougaro-documentation","text":"Warning This documentation is a work-in-progress and is not actually the most up-to-date source of information. For the actual documentation (that will soon be moved here), see the wiki","title":"Welcome to the Nougaro documentation"},{"location":"#overview","text":"Nougaro is an interpreted dynamic-typed programming language.","title":"Overview"},{"location":"#choose-your-version","text":"0.22","title":"Choose your version"},{"location":"#license","text":"This document is under the GNU FDL licence. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\".","title":"License"},{"location":"0.22/","text":"Nougaro 0.22.0-beta documentation This is the official documentation for Nougaro version 0.22.0-beta. Hello, world! Language reference: syntax, statements, \u2026 Basic syntax Number literals String literals Identifiers and keywords Operators Values Variables Tests (if statement) Standard library reference: builtins, modules, \u2026 Expanding Nougaro (for Python developers) Write libraries for Nougaro Internals","title":"Nougaro 0.22.0-beta documentation"},{"location":"0.22/#nougaro-0220-beta-documentation","text":"This is the official documentation for Nougaro version 0.22.0-beta. Hello, world! Language reference: syntax, statements, \u2026 Basic syntax Number literals String literals Identifiers and keywords Operators Values Variables Tests (if statement) Standard library reference: builtins, modules, \u2026 Expanding Nougaro (for Python developers) Write libraries for Nougaro Internals","title":"Nougaro 0.22.0-beta documentation"},{"location":"0.22/hello_world/","text":"Hello, world! This is the \u201cHello, world!\u201d program in Nougaro. print(\"Hello, world!\") Alternatively: import hello If you want to use functionnal programming: def main() print(\"Hello, world!\") end main() If you want to use object-oriented programming: class Main def print_hello_world() print(\"Hello, world!\") end end Main().print_hello_world()","title":"Hello, world!"},{"location":"0.22/hello_world/#hello-world","text":"This is the \u201cHello, world!\u201d program in Nougaro. print(\"Hello, world!\") Alternatively: import hello If you want to use functionnal programming: def main() print(\"Hello, world!\") end main() If you want to use object-oriented programming: class Main def print_hello_world() print(\"Hello, world!\") end end Main().print_hello_world()","title":"Hello, world!"},{"location":"0.22/internals/","text":"Internals Features that had to be documented but that are mainly used for debugging purposes. Context variables __actual_context__ is the name of the function where the code is executed. May be <program> . __exec_from__ is the name of the parent of the function where the code is executed. If __actual_context__ is <program> , __exec_from__ is (shell) . If the code is inside a function foo that is directly in <program> , __exec_from__ is foo from <program> . If the code is inside a function bar executed from our foo (that is in <program> ), __exec_from__ is bar from foo . Base value __base_value__ is the base value (python class Value ). It is the parent class of all the other values. It is the only value to crash on == and != operators .","title":"Internals"},{"location":"0.22/internals/#internals","text":"Features that had to be documented but that are mainly used for debugging purposes.","title":"Internals"},{"location":"0.22/internals/#context-variables","text":"__actual_context__ is the name of the function where the code is executed. May be <program> . __exec_from__ is the name of the parent of the function where the code is executed. If __actual_context__ is <program> , __exec_from__ is (shell) . If the code is inside a function foo that is directly in <program> , __exec_from__ is foo from <program> . If the code is inside a function bar executed from our foo (that is in <program> ), __exec_from__ is bar from foo .","title":"Context variables"},{"location":"0.22/internals/#base-value","text":"__base_value__ is the base value (python class Value ). It is the parent class of all the other values. It is the only value to crash on == and != operators .","title":"Base value"},{"location":"0.22/Expanding/Write-libs/","text":"You are a Nougaro developer, and you want to write an amazing library to inplement python amazing things in Nougaro? You're at the right place!! You have to options: either writting it in Nougaro (with limited resources), either writting it in Python (with unlimited resources). Write libs in Nougaro Requirements You need to know how to code in Nougaro. Start coding The file should be named nameofthelib.noug and be located in the lib_ folder in the Nougaro repository. Simply write all your code. If you want something to be accessible when imported, use one of those syntaxes: : * export identifier (as identifier) * export (any expression) as identifier You can find examples of built-in modules written in Nougaro in the lib_ folder. Write libs in Python Warning Everything changed in 0.16.0-beta and in 0.19.0-beta Requirements You need to know how to code in Python. Don't worry, that's easy ;) Start coding The file should be named nameofthelib_.py (the \u201c_\u201d is VERY important!!) The file will be placed in the lib_ folder in the Nougaro repository. Paste this generic code in your file: # -*- coding:utf-8 -*- \"\"\" YourModuleName module YourModuleName is a module that do [...] and [...] and also [...]. \"\"\" # IMPORTS # nougaro modules imports from lib_.lib_to_make_libs import * # useful stuff to make libs. # built-in python imports # here put the useful python imports your module will need ;) __LIB_VERSION__ = 4 Note Lib versions depending on Nougaro versions: prior to 0.20.0: 1 0.20.0: 2 0.21.0: 3 0.22.0: 4 Lib with constants If your lib contains constants, you can add them to the code, outside any class. Use py2noug function imported from lib_to_make_libs to convert Python values to Nougaro values. Python types that can be converted into Nougaro values are: str , int , float , bool (which is converted to 0 or 1), list , tuple (converted into list), dict (converted into a list of lists, each sub-list is [key, value] ), None . Other types will return generic value Value , which you can't make anything with... Example: AMAZING_CONSTANT = py2noug(3, *default_pos()) # will be Number(3), type 'int' ANOTHER_AMAZING_CONSTANT = py2noug(\"Hello world :)\", *default_pos()) # will be String(\"Hello world :)\"), type 'str' ( py2noug and default_pos are imported from lib_to_make_libs ) Lib with functions If you want functions in your lib, paste this code in your file (replace the generic names/texts with appropriate things): class YourModuleName(ModuleFunction): \"\"\" YourModuleName Module \"\"\" functions: dict[str, builtin_function_dict] = {} def __init__(self, function_name: str): super().__init__(\"your_module_name\", function_name, \"https://link_to_report_bugs.com (not required)\", functions=self.functions) def copy(self): \"\"\"Return a copy of self\"\"\" copy = YourModuleName(self.name) return self.set_context_and_pos_to_a_copy(copy) def is_eq(self, other: Value): return isinstance(other, YourModuleName) and self.name == other.name Changed in 0.20.0-beta Prior to 0.20.0, the method is_eq was named get_comparison_eq and had this syntax: def get_comparison_eq(self, other: Value): if isinstance(other, YourModuleName): return Number(self.name == other.name, self.pos_start, other.pos_end).set_context(self.context), None return Number(False, self.pos_start, other.pos_end).set_context(self.context), None Then, to add a function, add a method in this class following this syntax: def execute_function_name(self, context: Context): \"\"\" Docstring (optional) \"\"\" assert context.symbol_table is not None ... functions[\"function_name\"] = { \"function\": execute_function_name, \"param_names\": [\"parameter_1\", \"parameter_2\"], \"optional_params\": [\"optional_parameter_1\"], \"should_respect_args_number\": True, # The two following values are used internally. # They are not documented, don\u2019t set them to True except if you know what you\u2019re doing. \"run_noug_dir\": False, \"noug_dir\": False } Changed in 0.22.0-beta Prior to 0.22.0-beta, the key \"run_noug_dir\" was called \"run_noug_dir_work_dir\" . keys param_names and optional_params should be of type list[str] . should_respect_args_number is a bool. It is True when the number of given arguments should match with the number of parameters, and False if not. You can then add code in your function. Get arguments To get the arguments given by the user in your functions, use context.symbol_table.getf(\"identifier\") Replace the identifier by the one you given to the parameter. If your parameter is optional and that the user didn\u2019t specified it, the default value is a Python None (not a Nougaro NoneValue ). Danger Please don\u2019t use .get symbol table method, it does NOT work in modules (even if it looks like) and should NOT be used. (The short explanation why is that this method looks for the name also in parent symbol table, so if an optional param is not given but the user defined a variable with that name, it will be taken as the value for that param, which is not what we want. We don\u2019t care about parent symbol table, so we just look in the current symbol table which only contains the parameters. The corresponding issue is #10 .) Values Important You often have to switch between Nougaro and Python values! To convert python to Nougaro values, use py2noug function. To convert Nougaro to python values, use noug2py . Both functions are imported from lib_to_make_libs . You reed a position with py2noug : you can simply put self.pos_start and self.pos_end or the position of any value you want. What to return? Values and errors. If you don't need to return anything, simply use return RTResult().success(NoneValue(*default_pos(), False)) . Return errors Oops! It crashed! How to say it to the user under a good shape? Simply use this syntax: return RTResult().failure(NameOfTheError( self.pos_start, self.pos_end, \"error message.\", context )) If the user gave you a value with an incorrect type, use: return RTResult().failure(RTTypeErrorF( bad_argument.pos_start, bad_argument.pos_end, \"first/second/third\u2026\", \"name of the module.name of the function\", \"type that should be found\", bad_argument, context )) Replace \"first/second/third\u2026\" by the actual index of the argument. If it is the first argument, put \"first\" , et c\u00e6tera. The error will print, for instance, second argument of builtin function 'name of the function' should be 'type that should be found', not 'type of (bad_argument)'. You can replace self by any Nougaro value, such as your arguments. For example, in the lib math : if value.value < 0: # we check if the value is greater than (or equal to) 0 return RTResult().failure(RTArithmeticError( value.pos_start, value.pos_end, \"first argument of the built-in function 'math.sqrt' must be greater than (or equal to) 0.\", exec_context, \"lib_.math_.Math.execute_math_sqrt\" )) All the errors available in a Module: RunTimeError : basic run-time error RTIndexError : IndexError RTArithmeticError : ArithmeticError RTNotDefinedError : NotDefinedError RTTypeErrorF : TypeError (you give a Number but you need a String) RTFileNotFoundError : FileNotFoundError RTAssertionError : AssertionError (not useful in libs...) RTAttributeError : AttributeError RTOverflowError : OverflowError RTRecursionError : RecursionError (new in 0.20.0) PythonError : PythonError: an error due to Python. Don\u2019t put a str error message: pass directly the Python Exception. Return values To return a Nougaro value, use return RTResult().success(value) To return a Python value, use return RTResult().success(py2noug(value, self.pos_start, self.pos_end)) WHAT_TO_IMPORT : DO NOT forget that one!! When you have finished coding your amazing lib, create the WHAT_TO_IMPORT dict. It tells to the Nougaro Interpreter what should be imported and with which name. Follow this syntax: WHAT_TO_IMPORT = { \"name_of_a_constant\": IDENTIFIER, \"name_of_a_function\": YourModuleName('function_name'), } The function name is what you specified as the key of the functions dictionary. Custom errors To use a custom error in your code, simply copy-paste this code: class YourErrorName(RunTimeError): \"\"\"YourErrorName is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.(nameofthelib)_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"YourErrorName\", origin_file=origin_file) Then, call it like any other errors (like this ) Note: origin_file is used for debugging. To trigger it, you can run: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> (anything that throws an error) Example: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> thisisnotdefined [identifier:\"thisisnotdefined\", end of file] list:[(var_access:[identifier:\"thisisnotdefined\"], False)] (from src.runtime.interpreter.Interpreter.visit_VarAccessNode (is NOT lib and close match in symbol table)) Traceback (most recent call last): In file <stdin>, line 1, in <program>: thisisnotdefined ^^^^^^^^^^^^^^^^ NotDefinedError: name 'thisisnotdefined' is not defined. Did you mean 'is_none'? nougaro> this is a syntax error [identifier:\"this\", identifier:\"is\", identifier:\"a\", identifier:\"syntax\", identifier:\"error\", end of file] (from src.parser.parser.Parser.statements) In file <stdin>, line 1: this is a syntax error ^^ InvalidSyntaxError: unexpected token: identifier:\"is\". nougaro> Here, origin_file is src.runtime.interpreter.Interpreter.visit_VarAccessNode and src.parser.parser.Parser.parse . Example: RTStatisticsError in built-in lib statistics class RTStatisticsError(RunTimeError): \"\"\"StatisticsError is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.statistics_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"StatisticsError\", origin_file=origin_file) Examples You can read builtin files stored in lib_ folder to make you a good idea of what a nice-coded lib is ;) Here you go! If you think that your lib is absolutely awesome, you can open a PR to submit your idea. The best ideas will be implemented into vanilla Nougaro! If you think that this document is incomplete, that it didn\u2019t help you, or just to find some help, open an issue .","title":"Write libs"},{"location":"0.22/Expanding/Write-libs/#write-libs-in-nougaro","text":"","title":"Write libs in Nougaro"},{"location":"0.22/Expanding/Write-libs/#requirements","text":"You need to know how to code in Nougaro.","title":"Requirements"},{"location":"0.22/Expanding/Write-libs/#start-coding","text":"The file should be named nameofthelib.noug and be located in the lib_ folder in the Nougaro repository. Simply write all your code. If you want something to be accessible when imported, use one of those syntaxes: : * export identifier (as identifier) * export (any expression) as identifier You can find examples of built-in modules written in Nougaro in the lib_ folder.","title":"Start coding"},{"location":"0.22/Expanding/Write-libs/#write-libs-in-python","text":"Warning Everything changed in 0.16.0-beta and in 0.19.0-beta","title":"Write libs in Python"},{"location":"0.22/Expanding/Write-libs/#requirements_1","text":"You need to know how to code in Python. Don't worry, that's easy ;)","title":"Requirements"},{"location":"0.22/Expanding/Write-libs/#start-coding_1","text":"The file should be named nameofthelib_.py (the \u201c_\u201d is VERY important!!) The file will be placed in the lib_ folder in the Nougaro repository. Paste this generic code in your file: # -*- coding:utf-8 -*- \"\"\" YourModuleName module YourModuleName is a module that do [...] and [...] and also [...]. \"\"\" # IMPORTS # nougaro modules imports from lib_.lib_to_make_libs import * # useful stuff to make libs. # built-in python imports # here put the useful python imports your module will need ;) __LIB_VERSION__ = 4 Note Lib versions depending on Nougaro versions: prior to 0.20.0: 1 0.20.0: 2 0.21.0: 3 0.22.0: 4","title":"Start coding"},{"location":"0.22/Expanding/Write-libs/#lib-with-constants","text":"If your lib contains constants, you can add them to the code, outside any class. Use py2noug function imported from lib_to_make_libs to convert Python values to Nougaro values. Python types that can be converted into Nougaro values are: str , int , float , bool (which is converted to 0 or 1), list , tuple (converted into list), dict (converted into a list of lists, each sub-list is [key, value] ), None . Other types will return generic value Value , which you can't make anything with... Example: AMAZING_CONSTANT = py2noug(3, *default_pos()) # will be Number(3), type 'int' ANOTHER_AMAZING_CONSTANT = py2noug(\"Hello world :)\", *default_pos()) # will be String(\"Hello world :)\"), type 'str' ( py2noug and default_pos are imported from lib_to_make_libs )","title":"Lib with constants"},{"location":"0.22/Expanding/Write-libs/#lib-with-functions","text":"If you want functions in your lib, paste this code in your file (replace the generic names/texts with appropriate things): class YourModuleName(ModuleFunction): \"\"\" YourModuleName Module \"\"\" functions: dict[str, builtin_function_dict] = {} def __init__(self, function_name: str): super().__init__(\"your_module_name\", function_name, \"https://link_to_report_bugs.com (not required)\", functions=self.functions) def copy(self): \"\"\"Return a copy of self\"\"\" copy = YourModuleName(self.name) return self.set_context_and_pos_to_a_copy(copy) def is_eq(self, other: Value): return isinstance(other, YourModuleName) and self.name == other.name Changed in 0.20.0-beta Prior to 0.20.0, the method is_eq was named get_comparison_eq and had this syntax: def get_comparison_eq(self, other: Value): if isinstance(other, YourModuleName): return Number(self.name == other.name, self.pos_start, other.pos_end).set_context(self.context), None return Number(False, self.pos_start, other.pos_end).set_context(self.context), None Then, to add a function, add a method in this class following this syntax: def execute_function_name(self, context: Context): \"\"\" Docstring (optional) \"\"\" assert context.symbol_table is not None ... functions[\"function_name\"] = { \"function\": execute_function_name, \"param_names\": [\"parameter_1\", \"parameter_2\"], \"optional_params\": [\"optional_parameter_1\"], \"should_respect_args_number\": True, # The two following values are used internally. # They are not documented, don\u2019t set them to True except if you know what you\u2019re doing. \"run_noug_dir\": False, \"noug_dir\": False } Changed in 0.22.0-beta Prior to 0.22.0-beta, the key \"run_noug_dir\" was called \"run_noug_dir_work_dir\" . keys param_names and optional_params should be of type list[str] . should_respect_args_number is a bool. It is True when the number of given arguments should match with the number of parameters, and False if not. You can then add code in your function.","title":"Lib with functions"},{"location":"0.22/Expanding/Write-libs/#get-arguments","text":"To get the arguments given by the user in your functions, use context.symbol_table.getf(\"identifier\") Replace the identifier by the one you given to the parameter. If your parameter is optional and that the user didn\u2019t specified it, the default value is a Python None (not a Nougaro NoneValue ). Danger Please don\u2019t use .get symbol table method, it does NOT work in modules (even if it looks like) and should NOT be used. (The short explanation why is that this method looks for the name also in parent symbol table, so if an optional param is not given but the user defined a variable with that name, it will be taken as the value for that param, which is not what we want. We don\u2019t care about parent symbol table, so we just look in the current symbol table which only contains the parameters. The corresponding issue is #10 .)","title":"Get arguments"},{"location":"0.22/Expanding/Write-libs/#values","text":"Important You often have to switch between Nougaro and Python values! To convert python to Nougaro values, use py2noug function. To convert Nougaro to python values, use noug2py . Both functions are imported from lib_to_make_libs . You reed a position with py2noug : you can simply put self.pos_start and self.pos_end or the position of any value you want.","title":"Values"},{"location":"0.22/Expanding/Write-libs/#what-to-return-values-and-errors","text":"If you don't need to return anything, simply use return RTResult().success(NoneValue(*default_pos(), False)) .","title":"What to return? Values and errors."},{"location":"0.22/Expanding/Write-libs/#return-errors","text":"Oops! It crashed! How to say it to the user under a good shape? Simply use this syntax: return RTResult().failure(NameOfTheError( self.pos_start, self.pos_end, \"error message.\", context )) If the user gave you a value with an incorrect type, use: return RTResult().failure(RTTypeErrorF( bad_argument.pos_start, bad_argument.pos_end, \"first/second/third\u2026\", \"name of the module.name of the function\", \"type that should be found\", bad_argument, context )) Replace \"first/second/third\u2026\" by the actual index of the argument. If it is the first argument, put \"first\" , et c\u00e6tera. The error will print, for instance, second argument of builtin function 'name of the function' should be 'type that should be found', not 'type of (bad_argument)'. You can replace self by any Nougaro value, such as your arguments. For example, in the lib math : if value.value < 0: # we check if the value is greater than (or equal to) 0 return RTResult().failure(RTArithmeticError( value.pos_start, value.pos_end, \"first argument of the built-in function 'math.sqrt' must be greater than (or equal to) 0.\", exec_context, \"lib_.math_.Math.execute_math_sqrt\" )) All the errors available in a Module: RunTimeError : basic run-time error RTIndexError : IndexError RTArithmeticError : ArithmeticError RTNotDefinedError : NotDefinedError RTTypeErrorF : TypeError (you give a Number but you need a String) RTFileNotFoundError : FileNotFoundError RTAssertionError : AssertionError (not useful in libs...) RTAttributeError : AttributeError RTOverflowError : OverflowError RTRecursionError : RecursionError (new in 0.20.0) PythonError : PythonError: an error due to Python. Don\u2019t put a str error message: pass directly the Python Exception.","title":"Return errors"},{"location":"0.22/Expanding/Write-libs/#return-values","text":"To return a Nougaro value, use return RTResult().success(value) To return a Python value, use return RTResult().success(py2noug(value, self.pos_start, self.pos_end))","title":"Return values"},{"location":"0.22/Expanding/Write-libs/#what_to_import-do-not-forget-that-one","text":"When you have finished coding your amazing lib, create the WHAT_TO_IMPORT dict. It tells to the Nougaro Interpreter what should be imported and with which name. Follow this syntax: WHAT_TO_IMPORT = { \"name_of_a_constant\": IDENTIFIER, \"name_of_a_function\": YourModuleName('function_name'), } The function name is what you specified as the key of the functions dictionary.","title":"WHAT_TO_IMPORT : DO NOT forget that one!!"},{"location":"0.22/Expanding/Write-libs/#custom-errors","text":"To use a custom error in your code, simply copy-paste this code: class YourErrorName(RunTimeError): \"\"\"YourErrorName is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.(nameofthelib)_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"YourErrorName\", origin_file=origin_file) Then, call it like any other errors (like this ) Note: origin_file is used for debugging. To trigger it, you can run: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> (anything that throws an error) Example: nougaro> import debug;debug.enable() DEBUG mode is now ENABLED. [<module debug>, None] nougaro> thisisnotdefined [identifier:\"thisisnotdefined\", end of file] list:[(var_access:[identifier:\"thisisnotdefined\"], False)] (from src.runtime.interpreter.Interpreter.visit_VarAccessNode (is NOT lib and close match in symbol table)) Traceback (most recent call last): In file <stdin>, line 1, in <program>: thisisnotdefined ^^^^^^^^^^^^^^^^ NotDefinedError: name 'thisisnotdefined' is not defined. Did you mean 'is_none'? nougaro> this is a syntax error [identifier:\"this\", identifier:\"is\", identifier:\"a\", identifier:\"syntax\", identifier:\"error\", end of file] (from src.parser.parser.Parser.statements) In file <stdin>, line 1: this is a syntax error ^^ InvalidSyntaxError: unexpected token: identifier:\"is\". nougaro> Here, origin_file is src.runtime.interpreter.Interpreter.visit_VarAccessNode and src.parser.parser.Parser.parse .","title":"Custom errors"},{"location":"0.22/Expanding/Write-libs/#example-rtstatisticserror-in-built-in-lib-statistics","text":"class RTStatisticsError(RunTimeError): \"\"\"StatisticsError is an error that can be triggered ONLY via functions in this module.\"\"\" def __init__(self, pos_start: Position, pos_end: Position, details: str, context: Context, origin_file: str = \"lib_.statistics_\"): super().__init__(pos_start, pos_end, details, context, rt_error=False, error_name=\"StatisticsError\", origin_file=origin_file)","title":"Example: RTStatisticsError in built-in lib statistics"},{"location":"0.22/Expanding/Write-libs/#examples","text":"You can read builtin files stored in lib_ folder to make you a good idea of what a nice-coded lib is ;)","title":"Examples"},{"location":"0.22/Expanding/Write-libs/#here-you-go","text":"If you think that your lib is absolutely awesome, you can open a PR to submit your idea. The best ideas will be implemented into vanilla Nougaro! If you think that this document is incomplete, that it didn\u2019t help you, or just to find some help, open an issue .","title":"Here you go!"},{"location":"0.22/Language/01syntax/","text":"Very basic syntax This document covers the basic syntax of Nougaro. Comments There are two types of comments in Nougaro: single-line comments and multi-line comments. Single-line comments Single-line comments start with # and end with a new line. They can start at the beginning of a line or after some code. Example: # this is a single-line comment foo(bar) # this calls the function foo with the argument bar Multi-line comments Multi-line comments start with /* and end with */ . They can start and stop at any point in the code. Example: /* this is a multi line comment */ print(\"hello\") /* this is also a multi line comment*/ Multi-line comments can also be only on one line: print(\"hello\") /* this is a multi-line comment that is only on one line */ Multi-line comments are simply ignored, which mean you can do things such as: print( /* this is a comment */ \"hello\" /* this is another comment */) print(/* this is actually a comment*/ \"hello\") Multi-line comments can be nested: /* comment /* comment-inside comment*/ /* /* comment-ception */ */ comment */ Line joining If you don\u2019t have enough space on your line, you can join two \u201creal lines\u201d to form a Nougaro line, using a backspace. Example: var fruits = [\\ \"banana\", \\ \"apple\", \\ \"raspberry\", \\ \"pineapple\" \\ ] Blank lines Blank lines are ignored. Indentation Indentation is optional, as (mostly) every statement ends with end . Whitespaces Whitespaces are ignored everywhere (except in string literals and to differentiate things such as foobar and foo bar , or += and + = ).","title":"Very basic syntax"},{"location":"0.22/Language/01syntax/#very-basic-syntax","text":"This document covers the basic syntax of Nougaro.","title":"Very basic syntax"},{"location":"0.22/Language/01syntax/#comments","text":"There are two types of comments in Nougaro: single-line comments and multi-line comments.","title":"Comments"},{"location":"0.22/Language/01syntax/#single-line-comments","text":"Single-line comments start with # and end with a new line. They can start at the beginning of a line or after some code. Example: # this is a single-line comment foo(bar) # this calls the function foo with the argument bar","title":"Single-line comments"},{"location":"0.22/Language/01syntax/#multi-line-comments","text":"Multi-line comments start with /* and end with */ . They can start and stop at any point in the code. Example: /* this is a multi line comment */ print(\"hello\") /* this is also a multi line comment*/ Multi-line comments can also be only on one line: print(\"hello\") /* this is a multi-line comment that is only on one line */ Multi-line comments are simply ignored, which mean you can do things such as: print( /* this is a comment */ \"hello\" /* this is another comment */) print(/* this is actually a comment*/ \"hello\") Multi-line comments can be nested: /* comment /* comment-inside comment*/ /* /* comment-ception */ */ comment */","title":"Multi-line comments"},{"location":"0.22/Language/01syntax/#line-joining","text":"If you don\u2019t have enough space on your line, you can join two \u201creal lines\u201d to form a Nougaro line, using a backspace. Example: var fruits = [\\ \"banana\", \\ \"apple\", \\ \"raspberry\", \\ \"pineapple\" \\ ]","title":"Line joining"},{"location":"0.22/Language/01syntax/#blank-lines","text":"Blank lines are ignored.","title":"Blank lines"},{"location":"0.22/Language/01syntax/#indentation","text":"Indentation is optional, as (mostly) every statement ends with end .","title":"Indentation"},{"location":"0.22/Language/01syntax/#whitespaces","text":"Whitespaces are ignored everywhere (except in string literals and to differentiate things such as foobar and foo bar , or += and + = ).","title":"Whitespaces"},{"location":"0.22/Language/02number_literals/","text":"Number literals Here\u2019s all the different ways to write a number in Nougaro: 123 12.3 123e2 12.3e2 123e-2 123e+2 12.3e-2 12.3e+2 Note You can put + or - in front of the number to specify its sign. Example: -123 . Other bases: 0b01110 (base 2, binary) 0o17403 (base 8, octal) 0x4EF1A (base 16, hexadecimal) 0b10e30 0o70e30 Note 0xA0e30 will be interpreted as the hexadecimal number A0E30 ( 3*16^1 + 15*16^2 + 10*16^4 ) and not as 0xA0 * 10^30 _ in numbers Note You can put as much underscores ( _ ) as you want in a number literal, as long as the underscore are not at the beginning or at the end of the literal, or around the dot in floating-point numbers (ex: 10_694_254 is the same as 10694254 , 10_ is not valid, 12._3 is not valid and 12_._3 isn\u2019t either.)","title":"Number literals"},{"location":"0.22/Language/02number_literals/#number-literals","text":"Here\u2019s all the different ways to write a number in Nougaro: 123 12.3 123e2 12.3e2 123e-2 123e+2 12.3e-2 12.3e+2 Note You can put + or - in front of the number to specify its sign. Example: -123 . Other bases: 0b01110 (base 2, binary) 0o17403 (base 8, octal) 0x4EF1A (base 16, hexadecimal) 0b10e30 0o70e30 Note 0xA0e30 will be interpreted as the hexadecimal number A0E30 ( 3*16^1 + 15*16^2 + 10*16^4 ) and not as 0xA0 * 10^30","title":"Number literals"},{"location":"0.22/Language/02number_literals/#_-in-numbers","text":"Note You can put as much underscores ( _ ) as you want in a number literal, as long as the underscore are not at the beginning or at the end of the literal, or around the dot in floating-point numbers (ex: 10_694_254 is the same as 10694254 , 10_ is not valid, 12._3 is not valid and 12_._3 isn\u2019t either.)","title":"_ in numbers"},{"location":"0.22/Language/03string_literals/","text":"String literals String literals are delimited by \"\" , '' or \u00ab\u00bb . Examples: \"hello\" 'hello' \u00abhello\u00bb Escape characters: \\' : ' \\\" : \" \\\u00bb : \u00bb \\n : backline \\t : tab \\\\ : backslash \\xAA : unicode character number AA (hex) \\uAAAA : unicode character number AAAA (hex) \\UAAAAAAAA : unicode character number AAAAAAAA (hex) \\N{NAME} : unicode character with name NAME. Returns SyntaxError if it doesn\u2019t exist. Note The backslash isn\u2019t left if the next character is not recognised (example: \"\\/\" is the same as \"/\" , and not \"\\\\/\" ) Examples: 'I\\'m a string literal' \"He said: \\\"'I'm a string literal'\\\"\" \"\\\\ backslashes, \\t tabs and \\n backlines\" \u00abThis string has a \\N{NO BREAK SPACE}\u00bb \"\\N{Latin Small Letter C with Cedilla}: \\xe7\" \"\\N{Greek Small Letter Eta with Dasia and Oxia and Ypogegrammeni}: \\u1F95\" \"This is Person Shrugging (\ud83e\udd37): \\U0001f937\" Note You can use the meta nbspBetweenFrenchGuillemets to be forced to use a no-break-space or a narrow-no-break-space after \u00ab and before \u00bb . These NBSP are not counted in the string and this does not affect the other string delimiters.","title":"String literals"},{"location":"0.22/Language/03string_literals/#string-literals","text":"String literals are delimited by \"\" , '' or \u00ab\u00bb . Examples: \"hello\" 'hello' \u00abhello\u00bb Escape characters: \\' : ' \\\" : \" \\\u00bb : \u00bb \\n : backline \\t : tab \\\\ : backslash \\xAA : unicode character number AA (hex) \\uAAAA : unicode character number AAAA (hex) \\UAAAAAAAA : unicode character number AAAAAAAA (hex) \\N{NAME} : unicode character with name NAME. Returns SyntaxError if it doesn\u2019t exist. Note The backslash isn\u2019t left if the next character is not recognised (example: \"\\/\" is the same as \"/\" , and not \"\\\\/\" ) Examples: 'I\\'m a string literal' \"He said: \\\"'I'm a string literal'\\\"\" \"\\\\ backslashes, \\t tabs and \\n backlines\" \u00abThis string has a \\N{NO BREAK SPACE}\u00bb \"\\N{Latin Small Letter C with Cedilla}: \\xe7\" \"\\N{Greek Small Letter Eta with Dasia and Oxia and Ypogegrammeni}: \\u1F95\" \"This is Person Shrugging (\ud83e\udd37): \\U0001f937\" Note You can use the meta nbspBetweenFrenchGuillemets to be forced to use a no-break-space or a narrow-no-break-space after \u00ab and before \u00bb . These NBSP are not counted in the string and this does not affect the other string delimiters.","title":"String literals"},{"location":"0.22/Language/04identifiers_and_keywords/","text":"Identifiers and keywords Identifiers (variable names) can be composed of the 26 characters of the ASCII alphabet ( a to z \u202fthen A to Z ), in lower and upper case, the underscore _ and digits ( 0 to 9 ). Note An identifier can not start with a digit. Keywords The following identifiers are reserved and can not be used as variable names: and as assert break class continue def del do elif else end export for if import in loop not or read return step then to var while write xor","title":"Identifiers and keywords"},{"location":"0.22/Language/04identifiers_and_keywords/#identifiers-and-keywords","text":"Identifiers (variable names) can be composed of the 26 characters of the ASCII alphabet ( a to z \u202fthen A to Z ), in lower and upper case, the underscore _ and digits ( 0 to 9 ). Note An identifier can not start with a digit.","title":"Identifiers and keywords"},{"location":"0.22/Language/04identifiers_and_keywords/#keywords","text":"The following identifiers are reserved and can not be used as variable names: and as assert break class continue def del do elif else end export for if import in loop not or read return step then to var while write xor","title":"Keywords"},{"location":"0.22/Language/05operators/","text":"Operators Mathematical operators Here all the mathematical operators in Nougaro (ordered by priority): Nougaro Python Comments ^ ** power * * multiplication % % modulo / / division // // floor division + + addition - - substraction & & bitwise and | | bitwise or ^^ ^ bitwise xor ~ ~ bitwise not It respects operation priority and you can use parenthesis. Examples 3 * 4 returns 12 4 / 2 returns 2 1 + 1 returns 2 3 - 4 returns -1 10 % 7 returns 3 10 % 3 returns 1 10 // 7 returns 1 10 // 3 returns 3 5 ^ 2 returns 25 62 & 35 returns 34 ~1 returns -2 and ~-2 returns 1 5 + 5 * 3 + 2 returns 22 (5 + 5) * (3 + 2) returns 50 Test operators They are exactly same as Python ones: Nougaro Python Comments == == equals to != != different than < < less than <= <= less than or equals > > greater than >= >= greater than or equals in in check if a value is in another Note the in keyword can check if: int , float , str , list , DefaultValue or NoneValue is in a str any value is in a list Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta. Logical operators There is one logical operator that isn't here in Python. There is a list: Nougaro Python Comments and and boolean 'and' (binary operator) or or boolean 'or' (binary operator) xor ^ boolean 'exclusive or' (binary operator) not not boolean 'not' (inverter) (unary operator)","title":"Operators"},{"location":"0.22/Language/05operators/#operators","text":"","title":"Operators"},{"location":"0.22/Language/05operators/#mathematical-operators","text":"Here all the mathematical operators in Nougaro (ordered by priority): Nougaro Python Comments ^ ** power * * multiplication % % modulo / / division // // floor division + + addition - - substraction & & bitwise and | | bitwise or ^^ ^ bitwise xor ~ ~ bitwise not It respects operation priority and you can use parenthesis.","title":"Mathematical operators"},{"location":"0.22/Language/05operators/#examples","text":"3 * 4 returns 12 4 / 2 returns 2 1 + 1 returns 2 3 - 4 returns -1 10 % 7 returns 3 10 % 3 returns 1 10 // 7 returns 1 10 // 3 returns 3 5 ^ 2 returns 25 62 & 35 returns 34 ~1 returns -2 and ~-2 returns 1 5 + 5 * 3 + 2 returns 22 (5 + 5) * (3 + 2) returns 50","title":"Examples"},{"location":"0.22/Language/05operators/#test-operators","text":"They are exactly same as Python ones: Nougaro Python Comments == == equals to != != different than < < less than <= <= less than or equals > > greater than >= >= greater than or equals in in check if a value is in another Note the in keyword can check if: int , float , str , list , DefaultValue or NoneValue is in a str any value is in a list Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta.","title":"Test operators"},{"location":"0.22/Language/05operators/#logical-operators","text":"There is one logical operator that isn't here in Python. There is a list: Nougaro Python Comments and and boolean 'and' (binary operator) or or boolean 'or' (binary operator) xor ^ boolean 'exclusive or' (binary operator) not not boolean 'not' (inverter) (unary operator)","title":"Logical operators"},{"location":"0.22/Language/06values/","text":"Values Here is the list of the value types in Nougaro: int ( integers ). Internal type: int float ( floats ). Internal type: float str ( strings ). Internal type: str list ( lists ). Internal type: list NoneType ( None ). Internal type: NoneValue function . Internal type: func . module . Internal type: module constructor . Internal type: constructor object . Internal type: depends on the class\u2019 name, and it is <class> if the class has no name. Note Internal value types are base value (type: BaseValue ) and default value (type: DefaultValue ) Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta. Changed in 0.22.0-beta Before 0.22.0-beta, a distinction was made between func (user-defined function or function in a module written in Nougaro) and built-in func (built-in function or function in a module written in Python) Numbers Numbers represents real-life numbers. The two types of numbers are int and float . To declare a number, you can use a number literal . Operations that can be used between two numbers are: addition, substraction, multiplication, power. If the second number is non-zero, division, modulo and floor division can be used. All these operations follow the mathematical logic (except for 0^0, that returns 1). Multiplication can be used between a integer (type int ) and a string or a list . For example, 3*\"str\" returns \"strstrstr\" , and 2*[1, 2] returns [1, 2, 1, 2] . In boolean context, a number is true if it is non-zero. Strings The type of a string is str . To declare a string, you can use a string literal The only operation that can be used between strings is addition, which concatenates the string with the other. For example, \"hello, \" + \"world!\" returns \"hello, world!\" . Multiplication can be used between a string and an integer (type int ). For example, \"str\"*3 returns \"strstrstr\" . In boolean context, a string is true if it contains at least one character. Lists Lists are a succession of values. To declare a list, you can use brackets ( [] ), and put every value separated by a comma ( , ) inside. They may be 0 values. To create a list with elements from another list (and other elements), you can use this syntax: [1, 2, *list_, 5] (which is [1, 2, 3, 4, 5] if list_ is [3, 4] ). The only operation that can be used between two lists is multiplication, which extends the first list with the content of the second list. This can also be achieved using extend(list1, list2) Addition can be used between a list and any other value to add an element to the list. Substraction can be used between a list and an integer (type int ) to pop (i.e. delete) an element by index. This supports negative numbers. The returned value is the list after the pop. This can be achieved with pop(list, index) , although this returns the popped value. Multiplication can be used between a list and an integer (type int ). For example, [1, 2]*2 returns [1, 2, 1, 2] . Division can be used between a list and an integer (type int ) to get an element by index. This supports negative numbers. This can be achieved using list[index] or get(list, index) . In boolean context, a list is true if it is not empty None None is a value to denote the absence of other values. It is accessible trought the None built-in variable. No operation can be used on None . In boolean context, None is false.","title":"Values"},{"location":"0.22/Language/06values/#values","text":"Here is the list of the value types in Nougaro: int ( integers ). Internal type: int float ( floats ). Internal type: float str ( strings ). Internal type: str list ( lists ). Internal type: list NoneType ( None ). Internal type: NoneValue function . Internal type: func . module . Internal type: module constructor . Internal type: constructor object . Internal type: depends on the class\u2019 name, and it is <class> if the class has no name. Note Internal value types are base value (type: BaseValue ) and default value (type: DefaultValue ) Added in 0.22.0-beta DefaultValue is new in 0.22.0-beta. Changed in 0.22.0-beta Before 0.22.0-beta, a distinction was made between func (user-defined function or function in a module written in Nougaro) and built-in func (built-in function or function in a module written in Python)","title":"Values"},{"location":"0.22/Language/06values/#numbers","text":"Numbers represents real-life numbers. The two types of numbers are int and float . To declare a number, you can use a number literal . Operations that can be used between two numbers are: addition, substraction, multiplication, power. If the second number is non-zero, division, modulo and floor division can be used. All these operations follow the mathematical logic (except for 0^0, that returns 1). Multiplication can be used between a integer (type int ) and a string or a list . For example, 3*\"str\" returns \"strstrstr\" , and 2*[1, 2] returns [1, 2, 1, 2] . In boolean context, a number is true if it is non-zero.","title":"Numbers"},{"location":"0.22/Language/06values/#strings","text":"The type of a string is str . To declare a string, you can use a string literal The only operation that can be used between strings is addition, which concatenates the string with the other. For example, \"hello, \" + \"world!\" returns \"hello, world!\" . Multiplication can be used between a string and an integer (type int ). For example, \"str\"*3 returns \"strstrstr\" . In boolean context, a string is true if it contains at least one character.","title":"Strings"},{"location":"0.22/Language/06values/#lists","text":"Lists are a succession of values. To declare a list, you can use brackets ( [] ), and put every value separated by a comma ( , ) inside. They may be 0 values. To create a list with elements from another list (and other elements), you can use this syntax: [1, 2, *list_, 5] (which is [1, 2, 3, 4, 5] if list_ is [3, 4] ). The only operation that can be used between two lists is multiplication, which extends the first list with the content of the second list. This can also be achieved using extend(list1, list2) Addition can be used between a list and any other value to add an element to the list. Substraction can be used between a list and an integer (type int ) to pop (i.e. delete) an element by index. This supports negative numbers. The returned value is the list after the pop. This can be achieved with pop(list, index) , although this returns the popped value. Multiplication can be used between a list and an integer (type int ). For example, [1, 2]*2 returns [1, 2, 1, 2] . Division can be used between a list and an integer (type int ) to get an element by index. This supports negative numbers. This can be achieved using list[index] or get(list, index) . In boolean context, a list is true if it is not empty","title":"Lists"},{"location":"0.22/Language/06values/#none","text":"None is a value to denote the absence of other values. It is accessible trought the None built-in variable. No operation can be used on None . In boolean context, None is false.","title":"None"},{"location":"0.22/Language/07variables/","text":"Variables Definition Use the syntax var identifier = value (see identifiers and values ) to assign the value value to the variable named identifier . The expression var identifier = value returns value . To assign the same value to multiple variables, you can use var variable1 = var variable2 = var variable3 = value . If you want to assign multiple values to multiple variables, you can use var variable1, variable2 = value1, value2 . This can be used to swap variables: var a, b = b, a . Except for keywords , there are no prohibited variable name. Edition You can edit variables by multiple ways: var a = value ; var a += value : same as var a = a + value ; var a ++ : same as var a += 1 ; var a -= value : same as var a = a - value ; var a -- : same as var a -= 1 ; var a *= value : same as var a = a * value ; var a /= value : same as var a = a / value ; var a ^= value : same as var a = a ^ value ; var a //= value : same as var a = a // value ; var a %= value : same as var a = a % value ; var a ||= value : same as var a = a or value ; var a &&= value : same as var a = a and value ; var a ^^^= value : same as var a = a xor value ; var a |= value : same as var a = a | value ; var a &= value : same as var a = a & value ; var a ^^= value : same as var a = a ^^ value ; var a === value : same as var a = a == value ; var a <== value : same as var a = a <= value ; var a <<= value : same as var a = a < value ; var a >== value : same as var a = a >= value ; var a >>= value : same as var a = a > value . Info For details about these operators, see this page . Note You can also edit multiple variables at the same time: var a, b += 1, 2 : same as var a += 1 ; var b += 2 var a, b ++ : same as var a, b += 1, 1 var a, b //= b, a : same as var c = a ; var a //= b ; var b //= c ; del c Access To access to a variable, you can: give the identifier: foo (returns the value of foo ) use the special syntax: foo ? bar ? a ? b (returns the value of foo if it is defined, otherwise the value of bar ... You can put as much ? identifier as you want.) Then, you can put an expression at the end, such as 2 . In this case, the value returned will be 2 if none of the given identifiers is defined. Deletion If you don't need a variable anymore, you can delete it with the del keyword: del identifier . Examples var foo = var bar = 12 while foo != bar - 1 then var bar -= 1 (see while loop ) Example for deletion Create a variable a , the delete it: nougaro> var a = 1 1 nougaro> del a But be careful! It can return errors: nougaro> var a = 1 1 nougaro> del a nougaro> del a Traceback (more recent call last): In file <stdin>, line 1, in <program>: del a ^ NotDefinedError: a is not defined.","title":"Variables"},{"location":"0.22/Language/07variables/#variables","text":"","title":"Variables"},{"location":"0.22/Language/07variables/#definition","text":"Use the syntax var identifier = value (see identifiers and values ) to assign the value value to the variable named identifier . The expression var identifier = value returns value . To assign the same value to multiple variables, you can use var variable1 = var variable2 = var variable3 = value . If you want to assign multiple values to multiple variables, you can use var variable1, variable2 = value1, value2 . This can be used to swap variables: var a, b = b, a . Except for keywords , there are no prohibited variable name.","title":"Definition"},{"location":"0.22/Language/07variables/#edition","text":"You can edit variables by multiple ways: var a = value ; var a += value : same as var a = a + value ; var a ++ : same as var a += 1 ; var a -= value : same as var a = a - value ; var a -- : same as var a -= 1 ; var a *= value : same as var a = a * value ; var a /= value : same as var a = a / value ; var a ^= value : same as var a = a ^ value ; var a //= value : same as var a = a // value ; var a %= value : same as var a = a % value ; var a ||= value : same as var a = a or value ; var a &&= value : same as var a = a and value ; var a ^^^= value : same as var a = a xor value ; var a |= value : same as var a = a | value ; var a &= value : same as var a = a & value ; var a ^^= value : same as var a = a ^^ value ; var a === value : same as var a = a == value ; var a <== value : same as var a = a <= value ; var a <<= value : same as var a = a < value ; var a >== value : same as var a = a >= value ; var a >>= value : same as var a = a > value . Info For details about these operators, see this page . Note You can also edit multiple variables at the same time: var a, b += 1, 2 : same as var a += 1 ; var b += 2 var a, b ++ : same as var a, b += 1, 1 var a, b //= b, a : same as var c = a ; var a //= b ; var b //= c ; del c","title":"Edition"},{"location":"0.22/Language/07variables/#access","text":"To access to a variable, you can: give the identifier: foo (returns the value of foo ) use the special syntax: foo ? bar ? a ? b (returns the value of foo if it is defined, otherwise the value of bar ... You can put as much ? identifier as you want.) Then, you can put an expression at the end, such as 2 . In this case, the value returned will be 2 if none of the given identifiers is defined.","title":"Access"},{"location":"0.22/Language/07variables/#deletion","text":"If you don't need a variable anymore, you can delete it with the del keyword: del identifier .","title":"Deletion"},{"location":"0.22/Language/07variables/#examples","text":"var foo = var bar = 12 while foo != bar - 1 then var bar -= 1 (see while loop )","title":"Examples"},{"location":"0.22/Language/07variables/#example-for-deletion","text":"Create a variable a , the delete it: nougaro> var a = 1 1 nougaro> del a But be careful! It can return errors: nougaro> var a = 1 1 nougaro> del a nougaro> del a Traceback (more recent call last): In file <stdin>, line 1, in <program>: del a ^ NotDefinedError: a is not defined.","title":"Example for deletion"},{"location":"0.22/Language/08tests/","text":"Test statements List There is the list of test keywords in Nougaro : Nougaro Python if if then : elif elif else else Syntax if <cond> then <expr> if <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> else <expr> etc. Multi-line : if <cond> then <some code here> end if <cond> then <some code here> else <some other code> end if <cond> then <some code here> else <some other code> end etc. Behaviour The condition is checked. If it is true, the expression in the if branch is executed. Otherwise, Nougaro checks for an elif branch. If it exists, it re-checks the condition, etc. If none of the conditions is true and that there is an else branch, the expression in the else branch is executed. If there is no else branch, nothing is executed. Logicals constants Nougaro Python Comments True True equals to 1 False False equals to 0 Conditions Conditions can be any value , which will be interpreted in its boolean context. Conditions can also use test operators . For instance, a == b checks if a is equal to b , where a < b checks if a is strictly less than b .\u202fYou can chain multiple operators: a == b <= c != d checks if a is equal to b and if b is less than or equal to c and if c is different from d . Multiple conditions can be combined with boolean/logical operators . Here is the truth table of the logical operators: and a b a and b 0 0 0 0 1 0 1 0 0 1 1 1 or a b a or b 0 0 0 0 1 1 1 0 1 1 1 1 xor a b a xor b 0 0 0 0 1 1 1 0 1 1 1 0 not a not a 0 1 1 0 There is no priority amongst boolean operators, so for instance a and b or c xor d gives ((a and b) or c) xor d . After interpretation, a condition is always 0 or 1 ( False or True ). Examples if foo == bar then var foo = 12 if bar != foo then var foo = 12 else var bar = 13 * if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 end if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 else var foo = 12 end","title":"Test statements"},{"location":"0.22/Language/08tests/#test-statements","text":"","title":"Test statements"},{"location":"0.22/Language/08tests/#list","text":"There is the list of test keywords in Nougaro : Nougaro Python if if then : elif elif else else","title":"List"},{"location":"0.22/Language/08tests/#syntax","text":"if <cond> then <expr> if <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> else <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> if <cond> then <expr> elif <cond> then <expr> elif <cond> then <expr> else <expr> etc. Multi-line : if <cond> then <some code here> end if <cond> then <some code here> else <some other code> end if <cond> then <some code here> else <some other code> end etc.","title":"Syntax"},{"location":"0.22/Language/08tests/#behaviour","text":"The condition is checked. If it is true, the expression in the if branch is executed. Otherwise, Nougaro checks for an elif branch. If it exists, it re-checks the condition, etc. If none of the conditions is true and that there is an else branch, the expression in the else branch is executed. If there is no else branch, nothing is executed.","title":"Behaviour"},{"location":"0.22/Language/08tests/#logicals-constants","text":"Nougaro Python Comments True True equals to 1 False False equals to 0","title":"Logicals constants"},{"location":"0.22/Language/08tests/#conditions","text":"Conditions can be any value , which will be interpreted in its boolean context. Conditions can also use test operators . For instance, a == b checks if a is equal to b , where a < b checks if a is strictly less than b .\u202fYou can chain multiple operators: a == b <= c != d checks if a is equal to b and if b is less than or equal to c and if c is different from d . Multiple conditions can be combined with boolean/logical operators . Here is the truth table of the logical operators:","title":"Conditions"},{"location":"0.22/Language/08tests/#and","text":"a b a and b 0 0 0 0 1 0 1 0 0 1 1 1","title":"and"},{"location":"0.22/Language/08tests/#or","text":"a b a or b 0 0 0 0 1 1 1 0 1 1 1 1","title":"or"},{"location":"0.22/Language/08tests/#xor","text":"a b a xor b 0 0 0 0 1 1 1 0 1 1 1 0","title":"xor"},{"location":"0.22/Language/08tests/#not","text":"a not a 0 1 1 0 There is no priority amongst boolean operators, so for instance a and b or c xor d gives ((a and b) or c) xor d . After interpretation, a condition is always 0 or 1 ( False or True ).","title":"not"},{"location":"0.22/Language/08tests/#examples","text":"if foo == bar then var foo = 12 if bar != foo then var foo = 12 else var bar = 13 * if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 end if foo > bar and 12 <= variable then var bar = variable elif foo < bar xor foo > variable then var foo = 3 else var foo = 12 end","title":"Examples"},{"location":"0.22/stdlib/01builtin-variables/","text":"","title":"01builtin variables"},{"location":"0.22/stdlib/02builtin-functions/","text":"","title":"02builtin functions"}]}